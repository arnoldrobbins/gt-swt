C SEGMNT.FTN, SEGSRC, TRANSLATOR DEVELOPMENT GROUP, 09/07/82
C Main program for SEG
C Copyright (c) 1982, Prime Computer, Inc., Natick, MA 01760


C Description:
C
C Abnormal conditions:
C
C Implementation:
C
C Modifications:
C   Date   Programmer     Description of modification
C 09/07/82 D. M. Koch     Added variable SHARE names.
C 12/11/80 CEH-LSS-KJC-PMP Initial coding.
C
       SUBROUTINE MAIN
       STACK HEADER 34
       INTEGER ICMD(18),JCMD(18),I,J,ILENT,JLENT,INIT,IEND,INFO(8)
       INTEGER CONDNM(4),CNAMEL,CLFLAG
       LOGICAL ERROR, PRIMOS
       EXTERNAL CLEAN
       INTEGER NLENG,NAME(64)
       INTEGER ERR, SEG0, DELETE, REALNM
       INTEGER JFLAG,IHOUR,IMINN,IFLAG,STKSIZ,ITOPA(2),IS,ILEN,K,COUNT,
     + ISTART,CODE,ILONG(64),JLONG(64),SHFLAG,SHSEG,IARG,IU,SBSCR1,
     + SHUNIT,SBFUNT
       INTEGER CHARLN, WORDLN
       PARAMETER CHARLN = 17
       PARAMETER WORDLN = 9
       INTEGER VERS(WORDLN)
       INTEGER SEG1A,SEG1B,FUNIT,X,Y,ERRSEV,ACTION
       INTEGER NEWLEN
       PARAMETER NEWLEN = :4000
       INTEGER NEWBUF(NEWLEN)
       INTEGER*4 ITOP
       INTEGER IBUFFR(3),KBUFFR(:4000),SBUFFR(9)
       INTEGER BASNAM(128),ISEGNO(2),FILNAM(16)  /* SHARE NAME BUFFERS
       INTEGER PSD
       REAL*8 RETURN, EXITLB
       COMMON/EXITLB/EXITLB
       COMMON/PSDCOM/PSD
       COMMON/PRIMOS/PRIMOS
       COMMON/CLFLAG/CLFLAG
       COMMON/MONAME/NLENG,NAME
       COMMON/ERRSEV/ERRSEV
       COMMON/ACTION/ACTION
       EQUIVALENCE (ITOP,ITOPA)
$INSERT SYSCOM>ERRD.INS.FTN
$INSERT SYSCOM>KEYS.INS.FTN
$INSERT LODCOM.INS.FTN
$INSERT AUCOM.INS.FTN
C
       DATA ERRSEV/0/
       DATA CONDNM/'CLEANUP$'/
       DATA SEGDIR/0/         /* INITIALIZE FOR 1ST SRCH$$ CALL IN REALNM
       DATA CNAMEL/8/
       DATA ITOP/000000/
       DATA VERS/'[SEG rev 19.2.GT]'/
       DATA WRITEU/13/        /* TO SUPPORT LOAD SUBPROCESSOR MAP FUNCTIONALITY
                              /* THIS UNIT CAN NEVER BE SET UP BY K$GETU
       DATA BITMSK/:100000,:40000,:20000,:10000,:4000,:2000,:1000,
     +             :400,:200,:100,:40,:20,:10,:4,:2,:1/
C
C
       CALL MKLB$F($42, EXITLB)           /* FOR RETURN FROM AUNAME
       JFLAG=0
       CLFLAG =0                          /* INITIALIZE CLEANUP FLAG TO SAY
                                          /* THAT IT HAS NOT YET BEEN INVOKED.
       CALL MKON$F(CONDNM,CNAMEL,CLEAN)   /* LET'S SET UP THE CLEANUP ON-UNIT
                                          /* FOR THE INTERACTIVE SUBSYSTEM ERROR
                                          /* HANDLING ROUTINE (SS$ERR).


       PRIMOS = .TRUE.                    /* THE ONLY TIME WE READ FROM
                                          /* THE PRIMOS COMMAND LEVEL IS
                                          /* HERE. THIS FLAG IS USED BY
                                          /* RDT$$$ WHEN CHECKING FOR
                                          /* AUTOMATIC NAMING
       CALL CMRED$(ICMD,ILONG,64,ILENT)
       IF (ICMD(4) .NE. '-L') GO TO 5     /* NOT AUTOMATIC NAMING
        AUFLAG =1
        CALL TNOU(VERS,CHARLN)
        PRIMOS = .FALSE.                  /* WE ARE NO LONGER AT COMMAND LEVEL
        CALL ATCH$$(K$HOME,0,0,0,0,0)
        GO TO 9000                        /* GO INTO LOAD SUBPROCESSOR NOW
5      IF(ICMD(4).NE.'  ') GO TO 60
       PRIMOS = .FALSE.                   /* WE ARE NO LONGER AT COMMAND LEVEL
       CALL TNOU(VERS,CHARLN)
       IF(ICMD(11).EQ.1) GO TO 6000
10     CALL TNOUA('# ',2)
       CALL COMANL
       ACTION = 1                            /* INITIALIZE FLAG SO THAT SEG
                                             /* COMPLAINS IF WE TRY TO LOAD
                                             /* INTO ITS SYMBOL TABLE SEGMENT

       CALL CMRED$(ICMD,ILONG,64,ILENT)
       IF(ICMD(1).EQ.'PA') GO TO 1000
       IF(ICMD(1).EQ.'SH') GO TO 3000
       IF(ICMD(1).EQ.'SA') GO TO 4000
       IF(ICMD(1).EQ.'MO') GO TO 4000  /*EQUIVALENT TO 'SA'
       IF(ICMD(1).EQ.'PS') GO TO 6000
       IF(ICMD(1).EQ.'DE') GO TO 7000
       IF(ICMD(1).EQ.'MA') GO TO 8000
       IF(ICMD(1).EQ.'RE') GO TO 50
       IF(ICMD(1).EQ.'R ') GO TO 60
       IF(ICMD(1).EQ.'LO') GO TO 9000
       IF(ICMD(1).EQ.'VL') GO TO 9000  /*EQUIVALENT TO 'LO'
       IF(ICMD(1).EQ.'HE') GO TO 10000
       IF(ICMD(1).EQ.'TI') GO TO 11000
       IF(ICMD(1).EQ.'VE') GO TO 12000
       IF(ICMD(1).EQ.'SI') GO TO 2500
       IF(ICMD(1).EQ.'QU') GO TO 40
       IF(ICMD(1).EQ.'Q') GO TO 40
       IF(ICMD(1).EQ.'  ') GO TO 10    /* COMMENT LINE
       IF(ICMD(1).EQ.'* ') GO TO 10    /* COMMENT LINE
       IF(ICMD(1).EQ.'/*') GO TO 10    /* COMMENT LINE
30     CALL WRDOUT('COMMAND ERROR ')
       CALL SS$ERR
       ERRSEV =1
       GO TO 10
C
40     CALL SRCH$$(K$CLOS,0,0,SEGDIR,IARG,CODE)
       IF(CODE.NE.0) GO TO 90000
42     CALL SETRC$(ERRSEV)                  /* SET RETURN CODE FOR CPL.
       CALL EXIT
C
50     IF(ICMD(2).EQ.'ST') GO TO 2000
       IF(ICMD(2).NE.'SU') GO TO 30
C
C      RESUME A PROGRAM
C
60     ERR = SEG0(ILONG,ILENT,K$READ)  /* READ SEGMENT 0
       ERROR = ERR .NE. 0
       IF (ERROR.AND.PRIMOS) CALL ERRPR$(K$NRTN,E$NULL,0,0,0,0)  /* BACK TO PRIMOS,YEAAH!
       IF (ERROR) GO TO 30               /* ELSE GIVE ERROR MESSAGE
       IF(JFLAG.NE.0) GO TO 65
       CALL IOIT(1)
       JFLAG=1
       IF(ICMD(11).EQ.1) GO TO 6000
65     CALL SRCH$$(K$CLOS,0,0,SEGDIR,IARG,CODE)
       IF(CODE.NE.0) GO TO 90000       /*FATAL ERROR
       CALL VRUNIT
       CALL EXIT
C
C      REGURGITATE SAVE PARAMS FOR USER
C
1000   ERR = SEG0(ILONG,ILENT,K$READ)
       ERROR = ERR .NE. 0
       IF (ERROR) GO TO 30
       IF(ICMD(4).NE.'  ') JFLAG=0
       CALL WRDOUT('START(2), STACK(2), A, B, X, KEYS ')
       DO 1010 I=1,8
       CALL TOOCT(ISAVE(I))
       CALL TNOUA('  ',2)
1010   CONTINUE
       CALL TONL
       GO TO 10
C
C      RESTORE A PROGRAM
C
2000   ERR = SEG0(ILONG,ILENT,K$READ)
       ERROR = ERR .NE. 0
       IF (ERROR) GO TO 30
       CALL IOIT(1)
       JFLAG=1
       GO TO 10
C
2500   SHFLAG=1
       SHSEG=ICMD(10)
       ICMD(10)=ICMD(11)               /*REESET START ADDRESS
       GO TO 3010
C
3000   SHFLAG=0
3010   ERR = SEG0(ILONG,ILENT,K$READ)
       ERROR = ERR .NE. 0
       IF (ERROR) GO TO 30
       CALL TNOUA('FILE ID: ',9)
       CALL COMANL
       CALL RDTK$$(1,INFO,BASNAM,128,CODE)
       CALL INITNE(POINT1,:21,0)       /*INIT SEARCH ON SEGMENTS
3050   IF(NEXT(POINT1).EQ.0) GO TO 10  /*DONE
       IF(MAP1(P1SUBS).GT.0) GO TO 3050 /*NOT USED
       IF(SHFLAG.EQ.0) GO TO 3100
       IF(MAP1(P1SUBS+A$SEGM).EQ.SHSEG) GO TO 3200
       GO TO 3050
C
3100   IF(MAP1(P1SUBS+A$SEGM).GT.:4000) GO TO 10 /*DONE
C
C      FOUND A SEGMENT, SPOOL IT OUT
C
C
C      CREATE NAME OF FILE
C
3200   ISEGNO(1)=RT(RS(MAP1(P1SUBS+A$SEGM),6),3)+
     +  LT(RS(MAP1(P1SUBS+A$SEGM),1),8)+'00'
       ISEGNO(2)=RT(MAP1(P1SUBS+A$SEGM),3)+
     +  AND(LS(MAP1(P1SUBS+A$SEGM),5),:3400)+'00'
        CALL NAMGEN(BASNAM,ISEGNO,FILNAM)
       CALL SRCH$$(K$WRIT+K$GETU,FILNAM,32,SHUNIT,IARG,CODE) /*OPEN DESTINATION FILE
       IF(CODE.NE.0) GO TO 90000       /*FATAL ERROR
C
C      CHECK IF SPLIT SEGMNT,  IF SPLIT MUST USE BOTH PARTS
C
       IHOUR=0                         /*NEW-OLD FLAG
       SBSCR1=P1SUBS                   /*IF NOT SPLIT THIS WON'T CHANGE
       IF(AND(MAP1(P1SUBS),:4000).EQ.0) GO TO 3300 /*NOT SPLIT
       IF(AND(MAP1(P1SUBS),:10000).NE.0) GO TO 3300 /*NO PROC
       CALL NEXT(POINT1)               /*GET NEXT PART
       IF(AND(MAP1(P1SUBS).LT.0)) GO TO 3250
       P1SUBS=SBSCR1                   /*NOT USED
       GO TO 3300
C
3250   IF(AND(MAP1(P1SUBS)-MAP1(SBSCR1),:777).NE.0) IHOUR=1 /*OLD STYLE SPLIT
C
C      SET UP SAVE VECTOR
C
3300   SBUFFR(1)=MAP1(SBSCR1+A$LOW)    /*LOW FROM PROC PART
       IF(SBUFFR(1).EQ.-1) SBUFFR(1)=MAP1(P1SUBS+A$LOW)
       SBUFFR(2)=MAP1(P1SUBS+A$HIGH)   /*HIGH FROM DATA (=PROC?)
       IF(SBUFFR(2).EQ.0) SBUFFR(2)=MAP1(SBSCR1+A$HIGH)
       ITOPA(2)=SBUFFR(2)-SBUFFR(1) /*FOR TRUNCATION PURPOSES
       ITOP = ITOP + 10
       DO 3310 K=3,9                   /*FILL IN SAVE VECTOR
       SBUFFR(K)=ICMD(K+7)
3310   CONTINUE
       IF(SBUFFR(3).EQ.0) SBUFFR(3)=:1000 /*NON ZERO START ADDRESS
       SBUFFR(8)=ISAVE(1)     /* gt 09/15/83
       SBUFFR(9)=ISAVE(2)     /* gt 09/15/83
C
       CALL PRWF$$(K$WRIT,SHUNIT,LOC(SBUFFR),9,000000,IARG,CODE) /*WRITE IT OUT
       IF(CODE.NE.0) GO TO 90000       /*FATAL ERROR
C
C      NOW BUILD SAVE FILE PROPER
C
       IS=AND(MAP1(P1SUBS),:777)*32+1 /*POINT INTO SEGDIR AND BUFCTL
       INIT=RS(SBUFFR(1),11)           /*STARTING BUFFER
       IEND=RS(SBUFFR(2),11)           /*ENDING BUFFER
       DO 3800 K=INIT,IEND             /*DO EACH SEGMENT SUBFILE
C
       IF(IHOUR.EQ.0) GO TO 3350       /*NEW STYLE SPLIT OR NOT SPLIT
C
C      IF AT SPLIT ADDRESS, CHANGE POSITION IN SEGDIR
C
       IF(K*:4000.EQ.MAP1(P1SUBS+A$RANG)+1)
     +  IS=AND(MAP1(P1SUBS),:777)*32+1
3350   IU=IS+K                         /*SEGMENT SUBFILE, POSITION IN BUFTBL
       J=IU-1
       I=MOD(J,16)+1                   /*BIT
       J=RS(J,4)+1                     /*WORD
       IF(AND(BUFCTL(J),BITMSK(I)).NE.0) GO TO 3500  /*THIS SEGMENT WAS USED
       DO 3400 I=1,:4000               /*ZERO BUFFER, THEN WRITE IT OUT
       KBUFFR(I)=0
3400   CONTINUE
       GO TO 3600
C
C      USED SEGMENT, POSITION AND READ IT
C
3500   CALL SGDR$$(K$SPOS,SEGDIR,IU+OFFSET,IARG,CODE) /*POSITION IN SEGDIR
       IF(CODE.NE.0) GO TO 90000       /*FATAL ERROR
       CALL SRCH$$(K$ISEG+K$READ+K$GETU,SEGDIR,0,SBFUNT,IARG,CODE) /*OPEN SEGMENT SUBFILE
       IF(CODE.NE.0) GO TO 90000       /*FATAL ERROR
       CALL PRWF$$(K$READ,SBFUNT,LOC(KBUFFR),:4000,000000,IARG,CODE) /*READ IT
       IF(CODE.NE.0) GO TO 90000       /*FATAL ERROR
       CALL SRCH$$(K$CLOS,0,0,SBFUNT,IARG,CODE)  /*CLOSE SSEGMENT
       IF(CODE.NE.0) GO TO 90000
C
C      NOW WRITE IT OUT
C
3600   IF(K.NE.INIT) GO TO 3700        /*NOT FIRST BUFFER
       ISTART=SBUFFR(1)-K*:4000        /*STARTING POSITION IN BUFFER
       ILEN=:4000-ISTART               /*LENGTH TO WRITE
       CALL PRWF$$(K$WRIT,SHUNIT,LOC(KBUFFR(ISTART+1)),ILEN,
     +            000000,IARG,CODE) /*WRITE IT
       GO TO 3750
C
3700   CALL PRWF$$(K$WRIT,SHUNIT,LOC(KBUFFR),:4000,000000,IARG,CODE) /*WRITE IT
3750   IF(CODE.NE.0) GO TO 90000       /*FATAL ERROR
       IF(K.NE.IEND) GO TO 3800
C
C      TRUNCATE AND CLOSE FILE
C
       CALL PRWF$$(K$PREA+K$TRNC,SHUNIT,LOC(KBUFFR),0,ITOP,IARG,CODE) /*ITOP IS LAST LOCATION
       IF(CODE.NE.0) GO TO 90000
       CALL SRCH$$(K$CLOS,0,0,SHUNIT,IARG,CODE)  /*CLOSE IT
       IF(CODE.NE.0) GO TO 90000
3800   CONTINUE
       GO TO 3050
C
C
C      SAVE A PROGRAM
C
4000   ERR = SEG0(ILONG,ILENT,K$READ)
       ERROR = ERR .NE. 0
       IF (ERROR) GO TO 30
       IF(ICMD(4).EQ.'  ') GO TO 4005
       JFLAG=0
       GO TO 4010
4005   ILENT = NLENG                    /* WE NEED TO GET ONAME AND THE ITS
       COUNT = (NLENG+1)/2              /* LENGTH FROM OPENT$, SO USE THIS
       DO 4007 I =1,COUNT               /* COMMON BLOCK (MONAME)
       ILONG(I) = NAME(I)
4007   CONTINUE

4010   CALL TNOUA('$ ',2)
       CALL COMANL             /*GET A COMMAND LINE
       CALL CMRED$(JCMD,JLONG,64,JLENT)
C
       IF(JCMD(1).EQ.'PA') GO TO 4100
       IF(JCMD(1).EQ.'NE') GO TO 4200
       IF(JCMD(1).EQ.'WR') GO TO 4300
C       IF(JCMD(1).EQ.'SY') GO TO 4400
       IF(JCMD(1).EQ.'A ') GO TO 4500
       IF(JCMD(1).EQ.'B ') GO TO 4600
       IF(JCMD(1).EQ.'X ') GO TO 4700
       IF(JCMD(1).EQ.'KE') GO TO 4800
       IF(JCMD(1).EQ.'SK') GO TO 4900
       IF(JCMD(1).EQ.'ST') GO TO 5400
       IF(JCMD(1).EQ.'EN') GO TO 5500
       IF(JCMD(1).EQ.'RE') GO TO 5500
       IF(JCMD(1).EQ.'QU') GO TO 5500
       IF(JCMD(1).EQ.'Q ') GO TO 5500
4020   CALL WRDOUT('COMMAND ERROR ')
       CALL SS$ERR
       ERRSEV =1
       GO TO 4010
C
C      WRITE A PATCH OUT TO DISK
C
4100   IF(JFLAG.EQ.0) GO TO 4020       /*CAN'T DO IT
       IF(JCMD(10).LT.:4001) GO TO 4020 /*CAN'T DO IT
       CALL INITNE(POINT1,:21,0)       /*START SYMBOL TABLE SEARCH
4150   IF(NEXT(POINT1).EQ.0) GO TO 4020  /*ERROR
       IF(MAP1(P1SUBS+A$SEGM).NE.JCMD(10)) GO TO 4150
       IF(AND(MAP1(P1SUBS),:4000).EQ.0) GO TO 4160 /*NOT SPLIT
       IF(IUCAS(JCMD(12),MAP1(P1SUBS+A$RANG)).LE.0)
     +  GO TO 4160                     /*IT FITS
       IF(IUCAS(JCMD(11),MAP1(P1SUBS+A$RANG)).LE.0)
     +  GO TO 4020                     /*RANGE ACROSS SPLIT
       CALL NEXT(POINT1)               /*GET DATA PART
C
C      CHECK LOW, AND TOP
C
4160   IF(IUCAS(JCMD(11),MAP1(P1SUBS+A$LOW)).LE.0)
     +  MAP1(P1SUBS+A$LOW)=JCMD(11)
       IF(IUCAS(JCMD(12),MAP1(P1SUBS+A$HIGH)).GE.0)
     +  MAP1(P1SUBS+A$HIGH)=JCMD(12)
       IF(IUCAS(JCMD(12),MAP1(P1SUBS+A$TOP)).GE.0)
     +  MAP1(P1SUBS+A$TOP)=JCMD(12)
       IBUFFR(1)=MAP1(P1SUBS+A$SEGM)   /*SEGMENT OF PATCH
       IBUFFR(2)=AND(JCMD(11),:174000) /*CHUNKS ARE 4K(OCTAL) LONG
4170   INIT=LS(AND(MAP1(P1SUBS),:777),5)+RS(IBUFFR(2),11)+1 /*POS. IN BUFCTL
       CALL SEGPRW(2,IBUFFR,INIT)      /*WRITE IT OUT
       J=INIT-1
       I=MOD(J,16)+1                   /*BIT
       J=RS(J,4)+1                     /*WORD
       BUFCTL(J)=OR(BUFCTL(J),BITMSK(I))         /*SAY IT'S WRITTEN
       IBUFFR(2)=IBUFFR(2)+:4000       /*POINT TO NEXT SLOT
       IF(IUCAS(IBUFFR(2),JCMD(12)).LE.0) GO TO 4170
       GO TO 4010
C
C      CREATE A NEW RUN FILE
C
4200   IF(JFLAG.NE.0) GO TO 4250
       CALL WRDOUT('RESTORING RUN FILE')
       CALL IOIT(1)
       JFLAG=1
4250   ERR = SEG0(JLONG,JLENT,K$WRIT)  /* WRITE SEG0 BUFFERS TO NEW FILE)
       ERROR = ERR .NE. 0
       IF (ERROR) GO TO 4020
       FUNIT = 0 /* INITIALIZE FOR REALNM
       CODE= REALNM(K$READ+K$GETU+K$NSGS,ILONG,ILENT,FUNIT)
       IF (CODE.NE.0) GO TO 90000
C       CALL SRCH$$(K$CACC+K$RDWR,0,0,FUNIT,IARG,CODE)
C       IF (CODE.NE.0) GO TO 90000
       CALL SGDR$$(K$SPOS,FUNIT,1,IARG,CODE)
       IF (CODE.NE.0) GO TO 90000
       CALL SGDR$$(K$MSIZ,SEGDIR,2,IARG,CODE)
       IF (CODE.NE.0) GO TO 90000
       CALL SGDR$$(K$SPOS,SEGDIR,1,IARG,CODE)
       IF (CODE.NE.0) GO TO 90000
       CALL SRCH$$(K$READ+K$ISEG+K$NDAM+K$GETU,FUNIT,0,SEG1A,IARG,CODE)
       IF (CODE.NE.0) GO TO 90000
       CALL SRCH$$(K$WRIT+K$ISEG+K$NDAM+K$GETU,SEGDIR,0,SEG1B,IARG,CODE)
       IF (CODE.NE.0) GO TO 90000
       CALL PRWF$$(K$POSN+K$PREA,SEG1A,LOC(0),0,000000,IARG,CODE)
       IF (CODE.NE.0) GO TO 90000
       CALL PRWF$$(K$POSN+K$PREA,SEG1B,LOC(0),0,000000,IARG,CODE)
       IF (CODE.NE.0) GO TO 90000
4259   CALL PRWF$$(K$READ,SEG1A,LOC(NEWBUF),NEWLEN,000000,IARG,CODE)
       CALL PRWF$$(K$WRIT,SEG1B,LOC(NEWBUF),IARG,000000,X,Y)
       IF (IARG.NE.0) GO TO 4259
       CALL SRCH$$(K$CLOS+K$ISEG,FUNIT,0,SEG1A,IARG,CODE)
       IF (CODE.NE.0) GO TO 90000
       CALL SRCH$$(K$CLOS+K$ISEG,FUNIT,0,SEG1B,IARG,CODE)
       IF (CODE.NE.0) GO TO 90000
       CALL SRCH$$(K$CLOS,0,0,FUNIT,IARG,CODE)
       IF (CODE.NE.0) GO TO 90000
       DO 4260 I=1,40                  /*MOVE NAME INTO ILONG
       ILONG(I)=JLONG(I)
4260   CONTINUE
       ILENT=JLENT
C
C      AND FALL THROUGH
C
C
C      WRITE OUT SOME STUFF
C
4300   IF(JFLAG.EQ.0) GO TO 4020
       CALL IOIT(2)
       GO TO 4010
C
C      CREATE OR MODIFY A SYMBOL IN THE SYMBOL TABLE
C
C 4400   CALL SYMBOL(JCMD(4),JCMD(10),JCMD(11))
C        GO TO 4010
C
C      SET NEW A-REG SETTING
C
4500   ISAVE(5)=JCMD(10)
       GO TO 4010
C
C      SET NEW B-REG SETTING
C
4600   ISAVE(6)=JCMD(10)
       GO TO 4010
C
C      SET NEW X-REG SETTING
C
4700   ISAVE(7)=JCMD(10)
       GO TO 4010
C
C      SET NEW KEYS
C
4800   ISAVE(8)=JCMD(10)
       GO TO 4010
C
C      SET NEW STACK PARAMS
C
4900   STKSIZ=:6000
       IF(JCMD(10).NE.0) STKSIZ=JCMD(10)
       IF(JCMD(11).NE.0) GO TO 4910
       CALL STACK(STKSIZ)
       GO TO 4920
4910   ISAVE(3)=JCMD(10)
       ISAVE(4)=JCMD(11)
4920   IF(JCMD(12).EQ.0) GO TO 4010
       ITIME(24)=JCMD(12)
       GO TO 4010
C
C      CHANGE STARTING ADDRESS
C
5400   ISAVE(1)=JCMD(10)
       ISAVE(2)=JCMD(11)
       GO TO 4010
C
C      SAVE IS DONE - CLEAN UP
C
5500   CALL TIMDAT(ITIME,5)
       ERR = SEG0(ILONG,ILENT,K$WRIT,$30)  /* WRITE SEGMENT 0 BACK TO FILE)
       ERROR = ERR .NE. 0
       IF (ERROR) GO TO 30
       IF (JCMD(1).EQ.'QU') GO TO 40
       IF (JCMD(1).EQ.'Q ') GO TO 40
       GO TO 10
C
C      CALL VPSD
6000   CALL MKLB$F($6001, RETURN)
       CALL VPSD(RETURN)
6001   IF(PSD.NE.0) GO TO 65  /*EXECUTE RETURN, A=1
       GO TO 10  /*QUIT RETURN, A=0
C
7000   IF(NAMEQ$(ICMD,6,'DELETE',6).EQ.0) GO TO 30
       ERR =DELETE(ILONG,ILENT)
       ERROR = ERR .NE. 0
       IF (ERROR) GO TO 30
       GO TO 10
C
8000   ERR = SEG0(ILONG,ILENT,K$READ)
       ERROR = ERR .NE. 0
       IF (ERROR) GO TO 30
       IF(ICMD(4).NE.'  ') JFLAG=0
       CALL RDT$$$(ICMD(7),JLONG,64,JLENT)
       CALL PRTMAP(JLONG,JLENT,ICMD(10))
       IF(MAPFLG.EQ.0) GO TO 10
       CALL SRCH$$(K$CLOS,0,0,WRITEU,IARG,CODE) /*CLOSE MAP FILE
       CALL ERRPR$(K$NRTN,CODE,0,0,'SEGMNT',6)
       MAPFLG=0
       GO TO 10
C
9000   IF ( (ICMD(2).EQ.'* ') .OR. (AND(ICMD(3),:377).EQ.:252) .OR.
     1      (RS(ICMD(3),8).EQ.:252) ) GO TO 30       /*TYPO--PROTECT FILE
       JFLAG=0
       IFLAG=0
       IF(ICMD(4).NE.'* ') GO TO 9100
       IF(ICMD(7).EQ.'  ') GO TO 9050
       CALL RDT$$$(ICMD(7),JLONG,64,JLENT)
       ERR = SEG0(JLONG,JLENT,K$READ)
       ERROR = ERR .NE. 0
       IF (ERROR) GO TO 30
       IF(LOAD(JLONG,JLENT,1)) 60,10,40
C
9050   IFLAG=1
9100   IF(LOAD(ILONG,ILENT,IFLAG)) 60,10,40
C
10000  CALL WRDOUT('COMMANDS ARE: ')
       CALL WRDOUT('R(ESUME)')
       CALL WRDOUT('REST(ORE) ')
       CALL WRDOUT('PS(D) ')
       CALL WRDOUT('MA(P) - USUAL LOADER OPTIONS')
       CALL WRDOUT('SA(VE)')
       CALL WRDOUT('MO(DIFY) - SAME AS SAVE ')
       CALL WRDOUT('SH(ARE) - SPLIT OUT SEGMENTS')
       CALL WRDOUT('LO(AD)')
       CALL WRDOUT('VL(OAD) - SAME AS LOAD')
       CALL WRDOUT('LO(AD) * - ADD TO CURRENT RUN FILE')
       CALL WRDOUT('VL(OAD) * - SAME AS LOAD *')
       CALL WRDOUT('TI(ME) - OF LAST SAVE ')
       CALL WRDOUT('DELETE')
       CALL WRDOUT('VE(RSION) - OF SEG')
       CALL WRDOUT('QU(IT)')
       CALL TONL
       CALL TONL
       GO TO 10
C
11000  ERR = SEG0(ILONG,ILENT,K$READ)
       ERROR = ERR .NE. 0
       IF (ERROR) GO TO 30
       IHOUR=ITIME(4)/60
       IMINN=ITIME(4)-IHOUR*60
       I=IHOUR/10
       IHOUR=LS(I+:260,8)+(IHOUR-I*10+:260)
       I=IMINN/10
       IMINN=LS(I+:260,8)+IMINN-I*10+:260
       CALL TNOUA(ITIME,2)
       CALL TNOUA('-',1)
       CALL TNOUA(ITIME(2),2)
       CALL TNOUA('-',1)
       CALL TNOUA(ITIME(3),2)
       CALL TNOUA('  ',2)
       CALL TNOUA(IHOUR,2)
       CALL TNOUA(':',1)
       CALL TNOUA(IMINN,2)
       CALL TNOUA(':',1)
       I=ITIME(5)/10
       IMINN=LS(I+:260,8)+ITIME(5)-I*10+:260
       CALL TNOUA(IMINN,2)
       CALL TONL
       GO TO 10
C
12000  CALL TNOU(VERS,CHARLN)
       GO TO 10
C
90000  CALL ERRPR$(K$NRTN,CODE,0,0,'.MAIN.',6)
       END
