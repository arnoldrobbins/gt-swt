      INTEGER FUNCTION LOAD(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      INTEGER LOADB0,LOADA0,LOADD0,LOADC0,LOADE0,LOADF0,LOADJ0,LOADK0,LO
     *ADL0,LOADM0,LOADN0,LOADO0,LOADP0,LOADR0,LOADQ0,LOADS0,LOADEQ,LOADT
     *0,LOADV0,LOADGE,LOADW0,LOADGT,LOADIF,LOADX0,LOADY0,LOADLE,LOAEA0,L
     *OADZ0,LOADLT,LOAEC0,LOAEB0,LOAED0,LOAEE0,LOAEF0,LOADNE,LOAEG0,LOAE
     *H0,LOAEI0,LOADOR,LOAEJ0,LOAEK0,LOAEL0,LOAEM0,LOAEN0,LOAEO0,LOAEQ0,
     *LOAEP0,LOAER0,LOAET0,LOAES0,LOAEV0,LOAEW0,LOAEX0,LOAEZ0,LOAFB0,LOA
     *FA0,LOAFC0,LOAFD0,LOAFE0,LOAFG0,LOAFF0,LOADH0,LOADI0,LOADG0
      INTEGER AAAAA0
      INTEGER AAAAB0
      IF((EXPR.NE.0))GOTO 10000
        LOAD=0
        REGS=0
        RETURN
10000 AAAAA0=TMEMA0(EXPR)
      GOTO 10001
10002   LOAD=LOADB0(EXPR,REGS)
      GOTO 10003
10004   LOAD=LOADA0(EXPR,REGS)
      GOTO 10003
10005   LOAD=LOADD0(EXPR,REGS)
      GOTO 10003
10006   LOAD=LOADC0(EXPR,REGS)
      GOTO 10003
10007   LOAD=LOADE0(EXPR,REGS)
      GOTO 10003
10008   LOAD=LOADF0(EXPR,REGS)
      GOTO 10003
10009   LOAD=LOADJ0(EXPR,REGS)
      GOTO 10003
10010   LOAD=LOADK0(EXPR,REGS)
      GOTO 10003
10011   LOAD=LOADL0(EXPR,REGS)
      GOTO 10003
10012   LOAD=LOADM0(EXPR,REGS)
      GOTO 10003
10013   LOAD=LOADN0(EXPR,REGS)
      GOTO 10003
10014   LOAD=LOADO0(EXPR,REGS)
      GOTO 10003
10015   LOAD=LOADP0(EXPR,REGS)
      GOTO 10003
10016   LOAD=LOADR0(EXPR,REGS)
      GOTO 10003
10017   LOAD=LOADQ0(EXPR,REGS)
      GOTO 10003
10018   LOAD=LOADS0(EXPR,REGS)
      GOTO 10003
10019   LOAD=LOADEQ(EXPR,REGS)
      GOTO 10003
10020   LOAD=LOADT0(EXPR,REGS)
      GOTO 10003
10021   LOAD=LOADV0(EXPR,REGS)
      GOTO 10003
10022   LOAD=LOADGE(EXPR,REGS)
      GOTO 10003
10023   LOAD=LOADW0(EXPR,REGS)
      GOTO 10003
10024   LOAD=LOADGT(EXPR,REGS)
      GOTO 10003
10025   LOAD=LOADIF(EXPR,REGS)
      GOTO 10003
10026   LOAD=LOADX0(EXPR,REGS)
      GOTO 10003
10027   LOAD=LOADY0(EXPR,REGS)
      GOTO 10003
10028   LOAD=LOADLE(EXPR,REGS)
      GOTO 10003
10029   LOAD=LOAEA0(EXPR,REGS)
      GOTO 10003
10030   LOAD=LOADZ0(EXPR,REGS)
      GOTO 10003
10031   LOAD=LOADLT(EXPR,REGS)
      GOTO 10003
10032   LOAD=LOAEC0(EXPR,REGS)
      GOTO 10003
10033   LOAD=LOAEB0(EXPR,REGS)
      GOTO 10003
10034   LOAD=LOAED0(EXPR,REGS)
      GOTO 10003
10035   LOAD=LOAEE0(EXPR,REGS)
      GOTO 10003
10036   LOAD=LOADNE(EXPR,REGS)
      GOTO 10003
10037   LOAD=LOAEF0(EXPR,REGS)
      GOTO 10003
10038   LOAD=LOAEG0(EXPR,REGS)
      GOTO 10003
10039   LOAD=LOAEH0(EXPR,REGS)
      GOTO 10003
10040   LOAD=LOAEI0(EXPR,REGS)
      GOTO 10003
10041   LOAD=LOADOR(EXPR,REGS)
      GOTO 10003
10042   LOAD=LOAEJ0(EXPR,REGS)
      GOTO 10003
10043   LOAD=LOAEK0(EXPR,REGS)
      GOTO 10003
10044   LOAD=LOAEL0(EXPR,REGS)
      GOTO 10003
10045   LOAD=LOAEM0(EXPR,REGS)
      GOTO 10003
10046   LOAD=LOAEN0(EXPR,REGS)
      GOTO 10003
10047   LOAD=LOAEO0(EXPR,REGS)
      GOTO 10003
10048   LOAD=LOAEQ0(EXPR,REGS)
      GOTO 10003
10049   LOAD=LOAEP0(EXPR,REGS)
      GOTO 10003
10050   LOAD=LOAER0(EXPR,REGS)
      GOTO 10003
10051   LOAD=LOAET0(EXPR,REGS)
      GOTO 10003
10052   LOAD=LOAES0(EXPR,REGS)
      GOTO 10003
10053   LOAD=LOAEV0(EXPR,REGS)
      GOTO 10003
10054   LOAD=LOAEW0(EXPR,REGS)
      GOTO 10003
10055   LOAD=LOAEX0(EXPR,REGS)
      GOTO 10003
10056   LOAD=LOAEZ0(EXPR,REGS)
      GOTO 10003
10057   LOAD=LOAFB0(EXPR,REGS)
      GOTO 10003
10058   LOAD=LOAFA0(EXPR,REGS)
      GOTO 10003
10059   LOAD=LOAFC0(EXPR,REGS)
      GOTO 10003
10060   LOAD=LOAFD0(EXPR,REGS)
      GOTO 10003
10061   LOAD=LOAFE0(EXPR,REGS)
      GOTO 10003
10062   LOAD=LOAFG0(EXPR,REGS)
      GOTO 10003
10063   LOAD=LOAFF0(EXPR,REGS)
      GOTO 10003
10064   LOAD=LOADH0(EXPR,REGS)
      GOTO 10003
10065   LOAD=LOADI0(EXPR,REGS)
      GOTO 10003
10066   LOAD=LOADG0(EXPR,REGS)
      GOTO 10003
10001 AAAAB0=AAAAA0+1
      GOTO(10038,10002,10004,10005,10006,10007,10008,10067,10009,10010, 
     *    10011,10012,10067,10013,10014,10015,10016,10017,10018,10019,  
     *   10021,10022,10023,10024,10025,10026,10067,10027,10028,10029,   
     *  10030,10031,10067,10032,10033,10034,10035,10036,10037,10038,    
     * 10039,10040,10041,10042,10043,10044,10045,10067,10046,10067,10067
     *,10047,10048,10049,10050,10051,10052,10053,10054,10055,10056,10057
     *,10058,10059,10060,10061,10062,10063,10067,10020,10064,10065,10066
     *),AAAAB0
10067   CALL PANIC('load: bad IMF op: *i*n.',TMEMA0(EXPR))
10003 RETURN
      END
      INTEGER FUNCTION LOADB0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      LOGICAL SAFE
      INTEGER LREGS,RREGS,OPREG
      INTEGER L,R
      INTEGER SEQ,LD,ST,GENMR,REACH,LOADU0
      INTEGER LRES,RRES,LAD(5),RAD(5),OPSIZE,OPINS,TAD(5)
      INTEGER AAAAC0
      INTEGER AAAAD0
      INTEGER AAAAE0
      INTEGER LEFTOP,RIGHT0
      INTEGER AAAAF0
      LEFTOP=TMEMA0(EXPR+2)
      RIGHT0=TMEMA0(EXPR+3)
      IF((TMEMA0(LEFTOP).NE.69))GOTO 10071
        LOADB0=LOADU0(EXPR,REGS)
        RETURN
10071 AAAAF0=TMEMA0(EXPR+1)
      GOTO 10072
10073   OPREG=:002000
        OPSIZE=1
        OPINS=1
      GOTO 10074
10075   OPREG=:001000
        OPSIZE=2
        OPINS=2
      GOTO 10074
10076   OPREG=:000400
        OPSIZE=2
        OPINS=22
      GOTO 10074
10077   OPREG=:000200
        OPSIZE=4
        OPINS=7
      GOTO 10074
10072 GOTO(10073,10075,10073,10075,10076,10077),AAAAF0
        CALL PANIC('load_addaa: bad data mode *i*n.',TMEMA0(EXPR+1))
10074 R=REACH(TMEMA0(EXPR+3),RREGS,RRES,RAD)
      CALL ALLOC0(OPSIZE,TAD)
      L=REACH(TMEMA0(EXPR+2),LREGS,LRES,LAD)
      GOTO 10078
10079   IF((.NOT.SAFE(LREGS,RREGS)))GOTO 10080
          AAAAC0=1
          GOTO 10068
10080     AAAAD0=1
          GOTO 10069
10083   CONTINUE
10082 GOTO 10084
10085   IF((.NOT.SAFE(LREGS,RREGS)))GOTO 10086
          AAAAC0=2
          GOTO 10068
10086     AAAAE0=1
          GOTO 10070
10089   CONTINUE
10088 GOTO 10084
10090   AAAAD0=2
        GOTO 10069
10078 IF((.NOT.SAFE(LREGS,OPREG)))GOTO 10092
      IF((.NOT.SAFE(RREGS,OPREG)))GOTO 10092
      GOTO 10079
10092 IF(SAFE(LREGS,OPREG))GOTO 10093
      IF((.NOT.SAFE(RREGS,OPREG)))GOTO 10093
      GOTO 10085
10093 IF((.NOT.SAFE(LREGS,OPREG)))GOTO 10094
      IF(SAFE(RREGS,OPREG))GOTO 10094
      GOTO 10090
10094 CONTINUE
        AAAAE0=2
        GOTO 10070
10095 CONTINUE
10084 CALL FREET0(TAD)
      REGS=OR(OPREG,OR(LREGS,RREGS))
      RETURN
10068 LOADB0=SEQ(L,LD(OPREG,LRES,LAD),R,GENMR(OPINS,RAD),ST(OPREG,LAD))
      GOTO 10096
10069 LOADB0=SEQ(R,LD(OPREG,RRES,RAD),L,GENMR(OPINS,LAD),ST(OPREG,LAD))
      GOTO 10097
10070 LOADB0=SEQ(R,LD(OPREG,RRES,RAD))
      LOADB0=SEQ(LOADB0,ST(OPREG,TAD),L,LD(OPREG,LRES,LAD),GENMR(OPINS,T
     *AD),ST(OPREG,LAD))
      GOTO 10098
10096 GOTO(10084,10084),AAAAC0
      GOTO 10096
10097 GOTO(10083,10084),AAAAD0
      GOTO 10097
10098 GOTO(10089,10095),AAAAE0
      GOTO 10098
      END
      INTEGER FUNCTION LOADA0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      LOGICAL SAFE,OPHAS0
      INTEGER LREGS,RREGS,OPREG
      INTEGER L,R
      INTEGER SEQ,LD,ST,GENMR,REACH,LOAD
      INTEGER LRES,RRES,LAD(5),RAD(5),OPSIZE,OPINS,TAD(5),I
      INTEGER AAAAG0
      AAAAG0=TMEMA0(EXPR+1)
      GOTO 10099
10100   OPREG=:002000
        OPSIZE=1
        OPINS=1
      GOTO 10101
10102   OPREG=:001000
        OPSIZE=2
        OPINS=2
      GOTO 10101
10103   OPREG=:000400
        OPSIZE=2
        OPINS=22
      GOTO 10101
10104   OPREG=:000200
        OPSIZE=4
        OPINS=7
      GOTO 10101
10099 GOTO(10100,10102,10100,10102,10103,10104),AAAAG0
        CALL PANIC('load_add: bad data mode *i*n.',TMEMA0(EXPR+1))
10101 IF((.NOT.OPHAS0(TMEMA0(EXPR+3),0)))GOTO 10105
        LOADA0=LOAD(TMEMA0(EXPR+2),REGS)
        RETURN
10105 IF((.NOT.OPHAS0(TMEMA0(EXPR+2),0)))GOTO 10106
        LOADA0=LOAD(TMEMA0(EXPR+3),REGS)
        RETURN
10106 R=REACH(TMEMA0(EXPR+3),RREGS,RRES,RAD)
      CALL ALLOC0(OPSIZE,TAD)
      L=REACH(TMEMA0(EXPR+2),LREGS,LRES,LAD)
      GOTO 10107
10108   LOADA0=SEQ(L,LD(OPREG,LRES,LAD),R,GENMR(OPINS,RAD))
      GOTO 10109
10110   LOADA0=SEQ(R,LD(OPREG,RRES,RAD),L,GENMR(OPINS,LAD))
      GOTO 10109
10111   LOADA0=SEQ(L,LD(OPREG,LRES,LAD),R,GENMR(OPINS,RAD))
      GOTO 10109
10107 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10112
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10112
      GOTO 10108
10112 IF(SAFE(OPREG,RREGS))GOTO 10113
      IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10113
      GOTO 10110
10113 IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10114
      IF(SAFE(OPREG,LREGS))GOTO 10114
      GOTO 10111
10114 CONTINUE
        LOADA0=SEQ(R,LD(OPREG,RRES,RAD))
        LOADA0=SEQ(LOADA0,ST(OPREG,TAD),L,LD(OPREG,LRES,LAD),GENMR(OPINS
     *,TAD))
10109 CALL FREET0(TAD)
      REGS=OR(OPREG,OR(LREGS,RREGS))
      RETURN
      END
      INTEGER FUNCTION LOADD0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      LOGICAL SAFE
      INTEGER LREGS,RREGS,OPREG
      INTEGER LRES,RRES,LAD(5),RAD(5),OPINS,OPSIZE,TAD(5)
      INTEGER L,R,C,O
      INTEGER SEQ,GENMR,LD,ST,REACH,ANDAW0,ANDLW0,LOADU0
      INTEGER AAAAH0
      INTEGER AAAAI0
      INTEGER AAAAJ0
      INTEGER LEFTOP,RIGHT0
      INTEGER AAAAK0
      LEFTOP=TMEMA0(EXPR+2)
      RIGHT0=TMEMA0(EXPR+3)
      IF((TMEMA0(LEFTOP).NE.69))GOTO 10118
        LOADD0=LOADU0(EXPR,REGS)
        RETURN
10118 AAAAK0=TMEMA0(EXPR+1)
      GOTO 10119
10120   IF((TMEMA0(RIGHT0).NE.9))GOTO 10121
          L=REACH(LEFTOP,REGS,LRES,LAD)
          REGS=OR(REGS,:002000)
          LOADD0=SEQ(L,LD(:002000,LRES,LAD),ANDAW0(TMEMA0(RIGHT0+3)),ST(
     *:002000,LAD))
          RETURN
10121   OPREG=:002000
        OPINS=3
        OPSIZE=1
      GOTO 10122
10123   IF((TMEMA0(RIGHT0).NE.9))GOTO 10124
          L=REACH(LEFTOP,REGS,LRES,LAD)
          REGS=OR(REGS,:001000)
          LOADD0=SEQ(L,LD(:001000,LRES,LAD),ANDLW0(TMEMA0(RIGHT0+3)),ST(
     *:001000,LAD))
          RETURN
10124   OPREG=:001000
        OPINS=4
        OPSIZE=2
      GOTO 10122
10119 GOTO(10120,10123,10120,10123),AAAAK0
        CALL PANIC('load_andaa: bad data mode *i*n.',TMEMA0(EXPR+1))
10122 R=REACH(TMEMA0(EXPR+3),RREGS,RRES,RAD)
      CALL ALLOC0(OPSIZE,TAD)
      L=REACH(TMEMA0(EXPR+2),LREGS,LRES,LAD)
      GOTO 10125
10126   IF((.NOT.SAFE(LREGS,RREGS)))GOTO 10127
          AAAAH0=1
          GOTO 10115
10127     AAAAI0=1
          GOTO 10116
10130   CONTINUE
10129 GOTO 10131
10132   IF((.NOT.SAFE(LREGS,RREGS)))GOTO 10133
          AAAAH0=2
          GOTO 10115
10133     AAAAJ0=1
          GOTO 10117
10136   CONTINUE
10135 GOTO 10131
10137   AAAAI0=2
        GOTO 10116
10125 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10139
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10139
      GOTO 10126
10139 IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10140
      IF(SAFE(OPREG,LREGS))GOTO 10140
      GOTO 10132
10140 IF(SAFE(OPREG,RREGS))GOTO 10141
      IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10141
      GOTO 10137
10141 CONTINUE
        AAAAJ0=2
        GOTO 10117
10142 CONTINUE
10131 CALL FREET0(TAD)
      REGS=OR(OPREG,OR(LREGS,RREGS))
      RETURN
10115 LOADD0=SEQ(L,LD(OPREG,LRES,LAD),R,GENMR(OPINS,RAD),ST(OPREG,LAD))
      GOTO 10143
10116 LOADD0=SEQ(R,LD(OPREG,RRES,RAD),L,GENMR(OPINS,LAD),ST(OPREG,LAD))
      GOTO 10144
10117 LOADD0=SEQ(R,LD(OPREG,RRES,RAD))
      LOADD0=SEQ(LOADD0,ST(OPREG,TAD),L,LD(OPREG,LRES,LAD),GENMR(OPINS,T
     *AD),ST(OPREG,LAD))
      GOTO 10145
10143 GOTO(10131,10131),AAAAH0
      GOTO 10143
10144 GOTO(10130,10131),AAAAI0
      GOTO 10144
10145 GOTO(10136,10142),AAAAJ0
      GOTO 10145
      END
      INTEGER FUNCTION LOADC0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      LOGICAL SAFE
      INTEGER LREGS,RREGS,OPREG
      INTEGER LRES,RRES,LAD(5),RAD(5),OPINS,OPSIZE,TAD(5)
      INTEGER L,R
      INTEGER SEQ,GENMR,LD,ST,REACH,LOAD,ANDAW0,ANDLW0
      INTEGER AAAAL0
      INTEGER AAAAM0
      INTEGER AAAAN0
      INTEGER LEFTOP,RIGHT0
      INTEGER AAAAO0
      LEFTOP=TMEMA0(EXPR+2)
      RIGHT0=TMEMA0(EXPR+3)
      AAAAO0=TMEMA0(EXPR+1)
      GOTO 10149
10150   IF((TMEMA0(RIGHT0).NE.9))GOTO 10151
          LOADC0=SEQ(LOAD(LEFTOP,REGS),ANDAW0(TMEMA0(RIGHT0+3)))
          RETURN
10151   IF((TMEMA0(LEFTOP).NE.9))GOTO 10152
          LOADC0=SEQ(LOAD(RIGHT0,REGS),ANDAW0(TMEMA0(LEFTOP+3)))
          RETURN
10152   OPREG=:002000
        OPINS=3
        OPSIZE=1
      GOTO 10153
10154   IF((TMEMA0(RIGHT0).NE.9))GOTO 10155
          LOADC0=SEQ(LOAD(LEFTOP,REGS),ANDLW0(TMEMA0(RIGHT0+3)))
          RETURN
10155   IF((TMEMA0(LEFTOP).NE.9))GOTO 10156
          LOADC0=SEQ(LOAD(RIGHT0,REGS),ANDLW0(TMEMA0(LEFTOP+3)))
          RETURN
10156   OPREG=:001000
        OPINS=4
        OPSIZE=2
      GOTO 10153
10149 GOTO(10150,10154,10150,10154),AAAAO0
        CALL PANIC('load_and: bad data mode *i*n.',TMEMA0(EXPR+1))
10153 R=REACH(TMEMA0(EXPR+3),RREGS,RRES,RAD)
      CALL ALLOC0(OPSIZE,TAD)
      L=REACH(TMEMA0(EXPR+2),LREGS,LRES,LAD)
      GOTO 10157
10158   AAAAL0=1
        GOTO 10146
10161   AAAAM0=1
        GOTO 10147
10163   AAAAL0=2
        GOTO 10146
10157 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10165
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10165
      GOTO 10158
10165 IF(SAFE(OPREG,RREGS))GOTO 10166
      IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10166
      GOTO 10161
10166 IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10167
      IF(SAFE(OPREG,LREGS))GOTO 10167
      GOTO 10163
10167 CONTINUE
        AAAAN0=1
        GOTO 10148
10168 CONTINUE
10160 CALL FREET0(TAD)
      REGS=OR(OPREG,OR(LREGS,RREGS))
      RETURN
10146 LOADC0=SEQ(L,LD(OPREG,LRES,LAD),R,GENMR(OPINS,RAD))
      GOTO 10169
10147 LOADC0=SEQ(R,LD(OPREG,RRES,RAD),L,GENMR(OPINS,LAD))
      GOTO 10160
10148 LOADC0=SEQ(R,LD(OPREG,RRES,RAD))
      LOADC0=SEQ(LOADC0,ST(OPREG,TAD),L,LD(OPREG,LRES,LAD),GENMR(OPINS,T
     *AD))
      GOTO 10168
10169 GOTO(10160,10160),AAAAL0
      GOTO 10169
      END
      INTEGER FUNCTION LOADE0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      LOGICAL SAFE
      INTEGER LREGS,RREGS,OPREG
      INTEGER LRES,RRES,LAD(5),RAD(5),TAD(5),OPSIZE,LISTE0,RISTE0,LTEMP0
     *(5),RTEMP0(5)
      INTEGER L,R
      INTEGER SEQ,LD,ST,REACH,LOAD,STFIE0,GENMR,GENCO0
      INTEGER AAAAP0
      INTEGER AAAAQ0
      INTEGER AAAAR0
      INTEGER AAAAS0
      INTEGER AAAAT0
      INTEGER AAAAU0
      INTEGER AAAAV0
      INTEGER AAAAW0
      IF((TMEMA0(TMEMA0(EXPR+2)).NE.69))GOTO 10175
        LOADE0=LOAD(TMEMA0(EXPR+3),RREGS)
        AAAAS0=TMEMA0(EXPR+1)
        GOTO 10176
10177     CALL ALLOC0(1,TAD)
          LOADE0=SEQ(LOADE0,GENMR(47,TAD),STFIE0(TMEMA0(EXPR+2),LREGS),G
     *ENMR(37,TAD))
          CALL FREET0(TAD)
          REGS=OR(LREGS,RREGS)
          RETURN
10178     CALL ALLOC0(2,TAD)
          LOADE0=SEQ(LOADE0,GENMR(48,TAD),STFIE0(TMEMA0(EXPR+2),LREGS),G
     *ENMR(38,TAD))
          CALL FREET0(TAD)
          REGS=OR(LREGS,RREGS)
          RETURN
10176   GOTO(10177,10178,10177,10178),AAAAS0
          CALL WARNI0('*i:  bad data mode used with bit field*n.',TMEMA0
     *(EXPR+1))
          LOADE0=0
          RETURN
10175 AAAAT0=TMEMA0(EXPR+1)
      GOTO 10179
10180   OPREG=:002000
        OPSIZE=1
      GOTO 10181
10182   OPREG=:001000
        OPSIZE=2
      GOTO 10181
10183   OPREG=:000400
        OPSIZE=2
      GOTO 10181
10184   OPREG=:000200
        OPSIZE=4
      GOTO 10181
10185   AAAAU0=TMEMA0(EXPR+4)
        GOTO 10186
10187     OPREG=:002000
          OPSIZE=1
        GOTO 10181
10189     OPREG=:001000
          OPSIZE=2
        GOTO 10181
10190     OPREG=:000200
          OPSIZE=4
        GOTO 10181
10186   GOTO(10187,10189,10191,10190),AAAAU0
10191     CALL ALLOC0(2,LTEMP0)
          CALL ALLOC0(2,RTEMP0)
          L=REACH(TMEMA0(EXPR+2),LREGS,LRES,LAD)
          IF((LRES.EQ.0))GOTO 10192
            CALL WARNI0('struct asg left operand not an lvalue*n.')
            LOADE0=0
            RETURN
10192     AAAAV0=LAD(1)
          GOTO 10193
10194       LISTE0=0
          GOTO 10195
10196       IF((LAD(2).EQ.:000001))GOTO 10198
            IF((LAD(2).EQ.:000002))GOTO 10198
            GOTO 10197
10198         LISTE0=0
              GOTO 10195
10197         LISTE0=1
10199     GOTO 10195
10200       LISTE0=1
          GOTO 10195
10195       IF((LISTE0.NE.1))GOTO 10202
              L=SEQ(L,GENMR(17,LAD))
              CALL ADCOPY(LTEMP0,LAD)
              L=SEQ(L,GENMR(48,LAD))
              LAD(1)=3
10201     GOTO 10202
10193     GOTO(10196,10200,10196,10200,10200,10194,10194,10194,10194,   
     *  10194),AAAAV0
            CALL WARNI0('*i:  bad left operand address mode*n.',LAD(1))
            LOADE0=0
            RETURN
10202     R=REACH(TMEMA0(EXPR+3),RREGS,RRES,RAD)
          IF((RRES.EQ.0))GOTO 10203
            CALL WARNI0('struct asg right operand not an lvalue*n.')
            LOADE0=0
            RETURN
10203     AAAAW0=RAD(1)
          GOTO 10204
10205       RISTE0=0
          GOTO 10206
10207       IF((LAD(2).EQ.:000001))GOTO 10209
            IF((LAD(2).EQ.:000002))GOTO 10209
            GOTO 10208
10209         RISTE0=0
              GOTO 10206
10208         RISTE0=1
10210     GOTO 10206
10211       RISTE0=1
          GOTO 10206
10206       IF((RISTE0.NE.1))GOTO 10213
              R=SEQ(R,GENMR(17,RAD))
              CALL ADCOPY(RTEMP0,RAD)
              R=SEQ(R,GENMR(48,RAD))
              RAD(1)=3
10212     GOTO 10213
10204     GOTO(10207,10211,10207,10211,10211,10205,10205,10205,10205,   
     *  10205),AAAAW0
            CALL WARNI0('*i:  bad right operand address mode *n.',RAD(1)
     *)
            LOADE0=0
            RETURN
10213     REGS=:003703
          LOADE0=SEQ(L,R,GENCO0(RAD,LAD,TMEMA0(EXPR+4)))
          CALL FREET0(LTEMP0)
          CALL FREET0(RTEMP0)
          RETURN
10179 GOTO(10180,10182,10180,10182,10183,10184,10185),AAAAT0
        CALL PANIC('load_assign: bad data mode *i*n.',TMEMA0(EXPR+1))
10181 R=REACH(TMEMA0(EXPR+3),RREGS,RRES,RAD)
      CALL ALLOC0(OPSIZE,TAD)
      L=REACH(TMEMA0(EXPR+2),LREGS,LRES,LAD)
      GOTO 10214
10215   AAAAP0=1
        GOTO 10172
10218   AAAAP0=2
        GOTO 10172
10220   IF((.NOT.SAFE(LREGS,RREGS)))GOTO 10221
          AAAAQ0=1
          GOTO 10173
10221     AAAAR0=1
          GOTO 10174
10224   CONTINUE
10223 GOTO 10217
10214 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10225
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10225
      GOTO 10215
10225 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10226
      IF(SAFE(OPREG,RREGS))GOTO 10226
      GOTO 10218
10226 IF(SAFE(OPREG,LREGS))GOTO 10227
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10227
      GOTO 10220
10227 CONTINUE
        AAAAR0=2
        GOTO 10174
10228 CONTINUE
10217 CALL FREET0(TAD)
      REGS=OR(OPREG,OR(LREGS,RREGS))
      RETURN
10172 LOADE0=SEQ(R,LD(OPREG,RRES,RAD),L,ST(OPREG,LAD))
      GOTO 10229
10173 LOADE0=SEQ(L,R,LD(OPREG,RRES,RAD),ST(OPREG,LAD))
      GOTO 10217
10174 LOADE0=SEQ(R,LD(OPREG,RRES,RAD))
      LOADE0=SEQ(LOADE0,ST(OPREG,TAD),L,LD(OPREG,0,TAD),ST(OPREG,LAD))
      GOTO 10231
10229 GOTO(10217,10217),AAAAP0
      GOTO 10229
10231 GOTO(10224,10228),AAAAR0
      GOTO 10231
      END
      INTEGER FUNCTION LOADF0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      INTEGER LEVEL,LAD(5)
      INTEGER SEQ,GENGE0,GENMR
      LOADF0=0
      REGS=0
      LEVEL=TMEMA0(EXPR+1)
      IF((LEVEL.GT.BREAK0))GOTO 10233
      IF((LEVEL.LT.1))GOTO 10233
      GOTO 10232
10233   CALL WARNI0('load_break: improper break level *i*n.',LEVEL)
        GOTO 10234
10232   LEVEL=BREAK0-LEVEL+1
        LAD(1)=10
        LAD(3)=BREAL0(LEVEL)
        LOADF0=SEQ(GENMR(32,LAD),GENGE0(19))
10234 RETURN
      END
      INTEGER FUNCTION LOADJ0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      INTEGER OPREG
      INTEGER AD(5),RES
      INTEGER SEQ,REACH,LD,GENGE0,GENMR
      INTEGER AAAAX0
      LOADJ0=REACH(TMEMA0(EXPR+2),REGS,RES,AD)
      AAAAX0=TMEMA0(EXPR+1)
      GOTO 10235
10236   LOADJ0=SEQ(LOADJ0,LD(:002000,RES,AD),GENGE0(8))
        REGS=OR(REGS,:002000)
      GOTO 10237
10238   LOADJ0=SEQ(LOADJ0,LD(:001000,RES,AD))
        AD(1)=7
        AD(2)=-1
        AD(3)=-1
        LOADJ0=SEQ(LOADJ0,GENMR(21,AD))
        REGS=OR(REGS,:001000)
      GOTO 10237
10235 GOTO(10236,10238,10236,10238),AAAAX0
        CALL PANIC('load_compl: bad data mode *i*n.',TMEMA0(EXPR+1))
10237 RETURN
      END
      INTEGER FUNCTION LOADK0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      INTEGER OPREG
      INTEGER RES,AD(5)
      INTEGER REACH,LD
      INTEGER AAAAY0
      LOADK0=REACH(EXPR,REGS,RES,AD)
      AAAAY0=TMEMA0(EXPR+1)
      GOTO 10239
10240   OPREG=:002000
      GOTO 10241
10242   OPREG=:001000
      GOTO 10241
10243   OPREG=:000400
      GOTO 10241
10244   OPREG=:000200
      GOTO 10241
10239 GOTO(10240,10242,10240,10242,10243,10244),AAAAY0
        CALL PANIC('load_const: bad data mode *i*n.',TMEMA0(EXPR+1))
10241 LOADK0=LD(OPREG,0,AD)
      REGS=OPREG
      RETURN
      END
      INTEGER FUNCTION LOADL0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      INTEGER LABEL,AD(5)
      INTEGER MKLAB0
      REAL * 8 KLUGE
      INTEGER CONV
      INTEGER LOAD,GENGE0,GENBR0,GENMR,SEQ
      INTEGER MESG(30)
      INTEGER AAAAZ0
      INTEGER AAABA0
      INTEGER AAABB0
      INTEGER AAABC0
      INTEGER AAABD0
      INTEGER AAABE0
      INTEGER AAABF0
      INTEGER AAABG0
      INTEGER AAABH0
      EQUIVALENCE (KLUGE,AD(2))
      DATA MESG/236,239,225,228,223,227,239,238,246,229,242,244,186,160,
     *226,225,228,160,244,225,242,231,229,244,160,237,239,228,229,0/
      LOADL0=LOAD(TMEMA0(EXPR+3),REGS)
      CONV=0
      AAAAZ0=TMEMA0(EXPR+1)
      GOTO 10245
10246   AAABA0=TMEMA0(EXPR+2)
        GOTO 10247
10248     CONV=GENGE0(65)
          REGS=OR(REGS,:001000)
        GOTO 10254
10250     CONV=GENGE0(105)
          REGS=OR(REGS,:001000)
        GOTO 10254
10251     CONV=GENGE0(20)
          REGS=OR(REGS,:000400)
        GOTO 10254
10252     CONV=SEQ(GENGE0(20),GENGE0(18))
          REGS=OR(REGS,:000200)
        GOTO 10254
10247   AAABB0=AAABA0-1
        GOTO(10248,10253,10250,10251,10252),AAABB0
10253     CALL PANIC('*s *i*n.',MESG,TMEMA0(EXPR+2))
10249 GOTO 10254
10255   AAABC0=TMEMA0(EXPR+2)
        GOTO 10256
10257     CONV=GENGE0(97)
          REGS=OR(REGS,:002000)
        GOTO 10254
10259     CONV=GENGE0(21)
          REGS=OR(REGS,:000400)
        GOTO 10254
10260     CONV=SEQ(GENGE0(21),GENGE0(18))
          REGS=OR(REGS,:000200)
        GOTO 10254
10256   GOTO(10257,10261,10257,10261,10259,10260),AAABC0
10261     CALL PANIC('*s *i*n.',MESG,TMEMA0(EXPR+2))
10258 GOTO 10254
10262   AAABD0=TMEMA0(EXPR+2)
        GOTO 10263
10264     CONV=GENGE0(105)
          REGS=OR(REGS,:001000)
        GOTO 10254
10266     CONV=SEQ(GENGE0(105),GENGE0(21))
          REGS=OR(REGS,:000400)
        GOTO 10254
10267     CONV=SEQ(GENGE0(105),GENGE0(21),GENGE0(18))
          REGS=OR(REGS,:000200)
        GOTO 10254
10263   AAABE0=AAABD0-1
        GOTO(10264,10268,10264,10266,10267),AAABE0
10268     CALL PANIC('*s *i*n.',MESG,TMEMA0(EXPR+2))
10265 GOTO 10254
10269   AAABF0=TMEMA0(EXPR+2)
        GOTO 10270
10271     CONV=GENGE0(97)
          REGS=OR(REGS,:002000)
        GOTO 10254
10273     LABEL=MKLAB0(1)
          AD(1)=9
          KLUGE=4294967296.0D0
          CONV=SEQ(GENGE0(21),GENGE0(18),GENBR0(24,LABEL),GENMR(7,AD),GE
     *NLA0(LABEL))
          REGS=OR(REGS,OR(:000400,:000200))
        GOTO 10254
10270   GOTO(10271,10274,10271,10274,10273,10273),AAABF0
10274     CALL PANIC('*s *i*n.',MESG,TMEMA0(EXPR+2))
10272 GOTO 10254
10275AAABG0=TMEMA0(EXPR+2)
        GOTO 10276
10277     CONV=GENGE0(34)
          REGS=OR(REGS,:002000)
        GOTO 10254
10279     CONV=GENGE0(35)
          REGS=OR(REGS,:001000)
        GOTO 10254
10280     CONV=GENGE0(18)
          REGS=OR(REGS,:000200)
        GOTO 10254
10276   GOTO(10277,10279,10277,10279,10281,10280),AAABG0
10281     CALL PANIC('*s *i*n.',MESG,TMEMA0(EXPR+2))
10278 GOTO 10254
10282   AAABH0=TMEMA0(EXPR+2)
        GOTO 10283
10284     CONV=GENGE0(34)
          REGS=OR(REGS,:002000)
        GOTO 10254
10286     CONV=GENGE0(35)
          REGS=OR(REGS,:001000)
        GOTO 10254
10287     CONV=GENGE0(22)
          REGS=OR(REGS,:000400)
        GOTO 10254
10283   GOTO(10284,10286,10284,10286,10287),AAABH0
          CALL PANIC('*s *i*n.',MESG,TMEMA0(EXPR+2))
10285 GOTO 10254
10245 GOTO(10246,10255,10262,10269,10275,10282),AAAAZ0
        CALL PANIC('load_convert: bad source mode *i*n.',TMEMA0(EXPR+1))
10254 LOADL0=SEQ(LOADL0,CONV)
      RETURN
      END
      INTEGER FUNCTION LOADM0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      INTEGER RSVLI0
      INTEGER AD(5)
      INTEGER SEQ,GENGE0,GENEXT,GENLA0,GENIP
      REGS=0
      LOADM0=SEQ(0,GENEXT(TMEMA0(EXPR+2)),GENLA0(TMEMA0(EXPR+1)),GENIP(T
     *MEMA0(EXPR+2)),0)
      AD(1)=3
      AD(2)=:000002
      AD(3)=RSVLI0(2)
      AD(4)=1
      CALL ENTEV0(TMEMA0(EXPR+1),AD)
      RETURN
      END
      INTEGER FUNCTION LOADN0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      INTEGER AD(5),WAD(5),OPSIZE,LAB
      INTEGER MKLAB0
      INTEGER RSVST0
      INTEGER IEXP
      INTEGER SEQ,LOAD,ST,GENGE0,GENMR,GENLA0,GENBR0
      INTEGER XREGS,OPREG
      INTEGER AAABI0
      AD(1)=1
      AD(2)=:000001
      AD(3)=RSVST0(TMEMA0(EXPR+3))
      AD(4)=1
      CALL ENTEV0(TMEMA0(EXPR+1),AD)
      REGS=0
      LOADN0=0
      IEXP=TMEMA0(EXPR+2)
10288 IF((IEXP.EQ.0))GOTO 10289
        IF((TMEMA0(IEXP).NE.26))GOTO 10290
          AAABI0=TMEMA0(IEXP+1)
          GOTO 10291
10292       OPREG=:002000
            OPSIZE=1
          GOTO 10293
10294       OPREG=:001000
            OPSIZE=2
          GOTO 10293
10295       OPREG=:000400
            OPSIZE=2
          GOTO 10293
10296       OPREG=:000200
            OPSIZE=4
          GOTO 10293
10293       LOADN0=SEQ(LOADN0,LOAD(TMEMA0(IEXP+2),XREGS),ST(OPREG,AD))
            REGS=OR(REGS,XREGS)
            AD(3)=AD(3)+(OPSIZE)
          GOTO 10297
10291     GOTO(10292,10294,10292,10294,10295,10296),AAABI0
            IF((TMEMA0(IEXP+1).NE.7))GOTO 10298
              CALL WARNI0('stowed initializers have not been implemented
     **n.')
              GOTO 10299
10298         CALL WARNI0('bad dynm init expr mode (*i)*n.',TMEMA0(IEXP+
     *1))
10299     CONTINUE
10297     IEXP=TMEMA0(IEXP+3)
          GOTO 10288
10290     IF((TMEMA0(IEXP).NE.68))GOTO 10301
            OPSIZE=TMEMA0(IEXP+1)
            REGS=OR(REGS,:002000)
            IF((OPSIZE.LT.12))GOTO 10302
              REGS=OR(REGS,OR(:000200,:000100))
              LOADN0=SEQ(LOADN0,GENGE0(9),GENGE0(20),GENGE0(18))
              WAD(1)=6
              WAD(2)=OPSIZE-MOD(OPSIZE,4)-4
              LAB=MKLAB0(1)
              LOADN0=SEQ(LOADN0,GENMR(37,WAD),GENLA0(LAB),GENGE0(95))
              AD(1)=2
              WAD(1)=6
              WAD(2)=4
              LOADN0=SEQ(LOADN0,GENMR(14,AD),GENMR(52,WAD),GENBR0(18,LAB
     *))
              AD(3)=OPSIZE-MOD(OPSIZE,4)
              AD(1)=1
              OPSIZE=MOD(OPSIZE,4)
10302       IF((OPSIZE.LT.4))GOTO 10303
              REGS=OR(REGS,:000200)
              LOADN0=SEQ(LOADN0,GENGE0(9),GENGE0(20),GENGE0(18))
10304         IF((OPSIZE.LT.4))GOTO 10305
                LOADN0=SEQ(LOADN0,GENMR(14,AD))
                AD(3)=AD(3)+(4)
                OPSIZE=OPSIZE-(4)
              GOTO 10304
10305       CONTINUE
10303       IF((OPSIZE.LE.0))GOTO 10306
              LOADN0=SEQ(LOADN0,GENGE0(9))
10307         IF((OPSIZE.EQ.0))GOTO 10308
                LOADN0=SEQ(LOADN0,GENMR(47,AD))
                AD(3)=AD(3)+(1)
                OPSIZE=OPSIZE-(1)
              GOTO 10307
10308       CONTINUE
10306       IEXP=TMEMA0(IEXP+2)
            GOTO 10309
10301       CALL WARNI0('bad dynm initializer node (*i)*n.',TMEMA0(IEXP)
     *)
            GOTO 10289
10309   CONTINUE
10300 GOTO 10288
10289 RETURN
      END
      INTEGER FUNCTION LOADO0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      INTEGER I,IEXP,INODE,CLIST,ITAIL,RNODE,LABEL
      INTEGER SEQ,GENLA0,GENDA0,GENBSZ,GENGE0,LOAD,GENIP0
      INTEGER STRSA0
      INTEGER OBJID0(102)
      INTEGER AD(5),J
      INTEGER CLAB
      INTEGER RSVLI0,MKLAB0
      INTEGER MESG(19)
      INTEGER AAABJ0
      DATA MESG/236,239,225,228,223,228,229,230,233,238,229,223,243,244,
     *225,244,186,160,0/
      I=0
      LABEL=GENLA0(TMEMA0(EXPR+1))
      IF((TMEMA0(EXPR+2).NE.0))GOTO 10310
        I=SEQ(I,LABEL,GENBSZ(TMEMA0(EXPR+3)))
        GOTO 10311
10310   CLIST=0
        ITAIL=0
        IEXP=TMEMA0(EXPR+2)
10312   IF((IEXP.EQ.0))GOTO 10313
          IF((TMEMA0(IEXP).NE.26))GOTO 10314
            INODE=TMEMA0(IEXP+2)
            AAABJ0=TMEMA0(INODE)
            GOTO 10315
10316         J=1
              GOTO 10319
10317         J=J+(1)
10319         IF((J.GT.TMEMA0(INODE+2)))GOTO 10320
                ITAIL=SEQ(ITAIL,GENDA0(TMEMA0(INODE+2+J)))
              GOTO 10317
10321         RNODE=TMEMA0(INODE+2)
              IF((TMEMA0(RNODE).NE.40))GOTO 10322
                ITAIL=SEQ(ITAIL,GENIP0(TMEMA0(RNODE+2)))
                GOTO 10320
10322           IF((TMEMA0(RNODE).NE.9))GOTO 10324
                  CLAB=RSVLI0(TMEMA0(RNODE+2))
                  CLAB=MKLAB0(1)
                  ITAIL=SEQ(ITAIL,GENIP0(CLAB))
                  CLIST=SEQ(CLIST,GENLA0(CLAB))
                  J=1
                  GOTO 10327
10325             J=J+(1)
10327             IF((J.GT.TMEMA0(RNODE+2)))GOTO 10328
                    CLIST=SEQ(CLIST,GENDA0(TMEMA0(RNODE+2+J)))
                  GOTO 10325
10324             CALL WARNI0('*sbad REFTO initializer*n.',MESG)
10328         CONTINUE
10323       GOTO 10320
10315       IF(AAABJ0.EQ.9)GOTO 10316
            IF(AAABJ0.EQ.51)GOTO 10321
              CALL WARNI0('*sbad initializer node*n.',MESG)
10320       IEXP=TMEMA0(IEXP+3)
            GOTO 10312
10314       IF((TMEMA0(IEXP).NE.68))GOTO 10330
              ITAIL=SEQ(ITAIL,GENBSZ(TMEMA0(IEXP+1)))
              IEXP=TMEMA0(IEXP+2)
              GOTO 10331
10330         CALL WARNI0('*sbad node type *i*n.',MESG,TMEMA0(IEXP))
              GOTO 10313
10331     CONTINUE
10329   GOTO 10312
10313   I=SEQ(I,CLIST,LABEL,ITAIL)
10311 AD(1)=1
      AD(2)=:000002
      AD(3)=RSVLI0(TMEMA0(EXPR+3))
      AD(4)=1
      CALL ENTEV0(TMEMA0(EXPR+1),AD)
      REGS=0
      LOADO0=I
      RETURN
      END
      INTEGER FUNCTION LOADP0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      INTEGER REACH,LD,SEQ
      INTEGER RES,AD(5),OPREG
      INTEGER AAABK0
      LOADP0=REACH(EXPR,REGS,RES,AD)
      AAABK0=TMEMA0(EXPR+1)
      GOTO 10332
10333   OPREG=:002000
      GOTO 10334
10335   OPREG=:001000
      GOTO 10334
10336   OPREG=:000400
      GOTO 10334
10337   OPREG=:000200
      GOTO 10334
10334   LOADP0=SEQ(LOADP0,LD(OPREG,RES,AD))
      GOTO 10338
10332 GOTO(10333,10335,10333,10335,10336,10337),AAABK0
        CALL WARNI0('load_deref: bad data mode *i*n.',TMEMA0(EXPR+1))
10338 REGS=OR(REGS,OPREG)
      RETURN
      END
C ---- Long Name Map ----
C loadcompl                      loadj0
C loadxoraa                      loafg0
C deletelit                      delev0
C enterent                       enter0
C flowfield                      flowf0
C geniplabel                     genip0
C genlabel                       genla0
C loaddiv                        loadq0
C loadlshiftaa                   loaea0
C loadpredec                     loael0
C otg$aentpb                     otg$a0
C Imem                           imema0
C loadrem                        loaep0
C putmoduleheader                putmo0
C enterlit                       enteu0
C generatestaticstuff            geneu0
C loadchecklower                 loadg0
C loaddefinestat                 loado0
C loadreturn                     loaer0
C setupswitch                    setuq0
C gengeneric                     genge0
C linksize                       links0
C loadandaa                      loadd0
C loadobject                     loaeh0
C loadproccall                   loaen0
C loadrefto                      loaeo0
C lookupext                      looku0
C ltempadltemp0
C alloctemp                      alloc0
C loadcheckupper                 loadi0
C loadwhileloop                  loafe0
C geniprtr                       geniq0
C loadrshiftaa                   loaet0
C loadseq                        loaex0
C voidswitch                     voidt0
C initializelabels               initi0
C loadsub                        loafa0
C clearobj                       cleax0
C deleteext                      delet0
C loadundefinedynm               loafd0
C reachindex                     reack0
C simplify                       simpl0
C stfield                        stfie0
C lfieldmask                     lfiel0
C loadoraa                       loaei0
C otg$dac                        otg$e0
C otg$mref                       otg$m0
C putmoduletrailer               putmp0
C resolveent                     resol0
C clearstack                     cleay0
C enterext                       entes0
C lshiftaby                      lshif0
C putstartdata                   putst0
C Smem                           smema0
C rtempad                        rtemp0
C loadconst                      loadk0
C loadmul                        loaeb0
C loadpostinc                    loaek0
C otg$ecb                        otg$g0
C putbranch                      putbr0
C resolvelit                     reson0
C voidfieldasgop                 voidf0
C Tmem                           tmema0
C EmitPMA                        emitp0
C flowswitch                     flowv0
C loadconvert                    loadl0
C loadforloop                    loadv0
C loadsand                       loaev0
C optimize                       optim0
C rsvstack                       rsvst0
C voidaddaa                      voida0
C gettree                        gettr0
C loadselect                     loaew0
C lookuplab                      lookv0
C otg$endlb                      otg$h0
C otg$rentlb                     otg$r0
C loadnot                        loaef0
C loadpreinc                     loaem0
C otg$rorglb                     otg$t0
C loadlabel                      loady0
C voidpostdec                    voidp0
C framecom                       frame0
C generateprocedures             genet0
C genswitch                      gensw0
C loaddeclarestat                loadm0
C otglabel                       otgla0
C reachobject                    reacl0
C rshiftaby                      rshif0
C Breaksp                        break0
C Stream1                        strea0
C deletelab                      deleu0
C getlitaddr                     getli0
C loadadd                        loada0
C loadcheckrange                 loadh0
C loadsor                        loaez0
C otg$endpb                      otg$i0
C Stream2                        streb0
C gencopy                        genco0
C loadassign                     loade0
C reachseq                       reacn0
C Stream3                        strec0
C enterlab                       entet0
C generateproc                   genes0
C initshfttableids               inits0
C loadfield                      loadt0
C otg$proc                       otg$p0
C otgmisc                        otgmi0
C resolveext                     resom0
C warning                        warni0
C Breakstack                     breal0
C clearent                       clear0
C loadbreak                      loadf0
C loaddivaa                      loadr0
C loadderef                      loadp0
C loadremaa                      loaeq0
C loadrtrip                      loaeu0
C lshiftlby                      lshig0
C otg$brnch                      otg$d0
C stacksize                      stack0
C Continuesp                     conti0
C andawith                       andaw0
C clearlit                       cleaw0
C gensjtolab                     gensk0
C loadxor                        loaff0
C overlap                        overl0
C genbranch                      genbr0
C loadlshift                     loadz0
C reachconst                     reaci0
C Rtrids                         rtrid0
C voidseq                        voids0
C Continuestack                  contj0
C getextaddr                     getex0
C lookupobj                      lookx0
C otg$rorg                       otg$s0
C reachselect                    reacm0
C arshiftaby                     arshi0
C getlabeladdr                   getla0
C loaddoloop                     loads0
C otg$blk                        otg$c0
C rightop                        right0
C initotg                        inito0
C loadand                        loadc0
C loadsubaa                      loafb0
C otg$gen                        otg$l0
C rshiftlby                      rshig0
C listemp                        liste0
C gendata                        genda0
C ldfield                        ldfie0
C loadshiftins                   loaey0
C Errors                         error0
C deleteobj                      delew0
C loadrshift                     loaes0
C otg$entlb                      otg$j0
C voidpostinc                    voidq0
C EmitObj                        emito0
C clearext                       cleas0
C flfield                        flfie0
C flowseq                        flowt0
C freetemp                       freet0
C genshift                       gensh0
C otg$orglb                      otg$o0
C otgpseudo                      otgps0
C reachassign                    reach0
C enterobj                       entev0
C loadgoto                       loadw0
C loadmulaa                      loaec0
C loadswitch                     loafc0
C putlabel                       putla0
C gensjforward                   gensj0
C mklabel                        mklab0
C setupframeowner                setup0
C voidpreinc                     voidr0
C Outfile                        outfi0
C andlwith                       andlw0
C loadnull                       loaeg0
C otg$entpb                      otg$k0
C reachderef                     reacj0
C Infile                         infil0
C ristemp                        riste0
C loadneg                        loaed0
C putmisc                        putmi0
C otg$apins                      otg$b0
C putgeneric                     putge0
C clearinstr                     cleat0
C clearlink                      cleav0
C flowconvert                    flowc0
C flowsand                       flows0
C loadfieldasgop                 loadu0
C otg$data                       otg$f0
C otg$xtip                       otg$x0
C putinstr                       putin0
C voidassign                     voidb0
C adequal                        adequ0
C arshiftlby                     arshj0
C loadaddaa                      loadb0
C loadnext                       loaee0
C ophasvalue                     ophas0
C strsave                        strsa0
C clearstr                       cleaz0
C cleartree                      cleba0
C flownot                        flown0
C otg$rslv                       otg$u0
C rsvlink                        rsvli0
C zerolit                        zerol0
C clearlab                       cleau0
C freestack                      frees0
C genextrtr                      genex0
C loadindex                      loadx0
C lookuplit                      lookw0
C otgbranch                      otgbr0
C objidstr                       objid0
C loadpostdec                    loaej0
C otg$uii                        otg$v0
C afieldmask                     afiel0
C flowsor                        flowu0
C generateentries                gener0
C loaddefinedynm                 loadn0
