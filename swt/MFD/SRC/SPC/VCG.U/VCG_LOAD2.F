      INTEGER FUNCTION LOADR0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      LOGICAL SAFE
      INTEGER AAAAA0
      INTEGER AAAAB0
      INTEGER PREP,L,R
      INTEGER GENGE0,GENMR,LD,ST,REACH,SEQ,DIVABY,DIVLBY,LOADU0
      INTEGER OPREG,LREGS,RREGS
      INTEGER LRES,RRES,LAD(5),RAD(5),TAD(5),OPSIZE,OPINS
      INTEGER LEFTOP,RIGHT0
      INTEGER AAAAC0
      LEFTOP=TMEMA0(EXPR+2)
      RIGHT0=TMEMA0(EXPR+3)
      IF((TMEMA0(LEFTOP).NE.69))GOTO 10002
        LOADR0=LOADU0(EXPR,REGS)
        RETURN
10002 AAAAC0=TMEMA0(EXPR+1)
      GOTO 10003
10004   IF((TMEMA0(RIGHT0).NE.9))GOTO 10005
          L=REACH(LEFTOP,REGS,LRES,LAD)
          REGS=OR(REGS,:002000)
          LOADR0=SEQ(L,LD(:002000,LRES,LAD),DIVABY(TMEMA0(RIGHT0+3),1),S
     *T(:002000,LAD))
          RETURN
10005   OPREG=:002000
        PREP=GENGE0(65)
        OPSIZE=1
        OPINS=15
      GOTO 10006
10007   IF((TMEMA0(RIGHT0).NE.9))GOTO 10008
          L=REACH(LEFTOP,REGS,LRES,LAD)
          REGS=OR(REGS,:002000)
          LOADR0=SEQ(L,LD(:002000,LRES,LAD),DIVABY(TMEMA0(RIGHT0+3),3),S
     *T(:002000,LAD))
          RETURN
10008   OPREG=:002000
        PREP=GENGE0(105)
        OPSIZE=1
        OPINS=15
      GOTO 10006
10009   IF((TMEMA0(RIGHT0).NE.9))GOTO 10010
          L=REACH(LEFTOP,REGS,LRES,LAD)
          REGS=OR(REGS,:001000)
          LOADR0=SEQ(L,LD(:001000,LRES,LAD),DIVLBY(TMEMA0(RIGHT0+3),1),S
     *T(:001000,LAD))
          RETURN
10010   OPREG=:001000
        PREP=GENGE0(66)
        OPSIZE=2
        OPINS=16
      GOTO 10006
10011   IF((TMEMA0(RIGHT0).NE.9))GOTO 10012
          L=REACH(LEFTOP,REGS,LRES,LAD)
          REGS=OR(REGS,:001000)
          LOADR0=SEQ(L,LD(:001000,LRES,LAD),DIVLBY(TMEMA0(RIGHT0+3),3),S
     *T(:001000,LAD))
          RETURN
10012   OPREG=:001000
        PREP=SEQ(GENGE0(33),GENGE0(12))
        OPSIZE=2
        OPINS=16
      GOTO 10006
10013   OPREG=:000400
        PREP=0
        OPSIZE=2
        OPINS=24
      GOTO 10006
10014   OPREG=:000200
        PREP=0
        OPSIZE=4
        OPINS=9
      GOTO 10006
10003 GOTO(10004,10009,10007,10011,10013,10014),AAAAC0
        CALL PANIC('load_divaa: bad operand mode *i*n.',TMEMA0(EXPR+1))
10006 R=REACH(TMEMA0(EXPR+3),RREGS,RRES,RAD)
      CALL ALLOC0(OPSIZE,TAD)
      L=REACH(TMEMA0(EXPR+2),LREGS,LRES,LAD)
      IF((LRES.EQ.0))GOTO 10016
        CALL WARNI0('load_divaa: left operand not lvalue*n.')
        LOADR0=0
        RETURN
10017   IF((.NOT.SAFE(LREGS,RREGS)))GOTO 10018
          AAAAA0=1
          GOTO 10000
10018     AAAAB0=1
          GOTO 10001
10021   CONTINUE
10020 GOTO 10022
10023   AAAAB0=2
        GOTO 10001
10025   IF((.NOT.SAFE(LREGS,RREGS)))GOTO 10026
          AAAAA0=2
          GOTO 10000
10026     AAAAB0=3
          GOTO 10001
10029   CONTINUE
10028 GOTO 10022
10016 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10030
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10030
      GOTO 10017
10030 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10031
      IF(SAFE(OPREG,RREGS))GOTO 10031
      GOTO 10023
10031 IF(SAFE(OPREG,LREGS))GOTO 10032
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10032
      GOTO 10025
10032 CONTINUE
        AAAAB0=4
        GOTO 10001
10033 CONTINUE
10022 CALL FREET0(TAD)
      REGS=OR(OPREG,OR(LREGS,RREGS))
      RETURN
10000 LOADR0=SEQ(L,LD(OPREG,LRES,LAD),PREP,R,GENMR(OPINS,RAD),ST(OPREG,L
     *AD))
      GOTO 10034
10001 LOADR0=SEQ(R,LD(OPREG,RRES,RAD))
      LOADR0=SEQ(LOADR0,ST(OPREG,TAD),L,LD(OPREG,LRES,LAD),PREP,GENMR(OP
     *INS,TAD),ST(OPREG,LAD))
      GOTO 10035
10034 GOTO(10022,10022),AAAAA0
      GOTO 10034
10035 GOTO(10021,10022,10029,10033),AAAAB0
      GOTO 10035
      END
      INTEGER FUNCTION LOADQ0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      LOGICAL SAFE
      INTEGER AAAAD0
      INTEGER AAAAE0
      INTEGER PREP,L,R
      INTEGER GENGE0,GENMR,LD,ST,REACH,SEQ,DIVABY,DIVLBY,LOAD
      INTEGER OPREG,LREGS,RREGS
      INTEGER LRES,RRES,LAD(5),RAD(5),TAD(5),OPSIZE,OPINS
      INTEGER LEFTOP,RIGHT0
      INTEGER AAAAF0
      LEFTOP=TMEMA0(EXPR+2)
      RIGHT0=TMEMA0(EXPR+3)
      AAAAF0=TMEMA0(EXPR+1)
      GOTO 10038
10039   IF((TMEMA0(RIGHT0).NE.9))GOTO 10040
          LOADQ0=SEQ(LOAD(LEFTOP,REGS),DIVABY(TMEMA0(RIGHT0+3),1))
          RETURN
10040   OPREG=:002000
        PREP=GENGE0(65)
        OPSIZE=1
        OPINS=15
      GOTO 10041
10042   IF((TMEMA0(RIGHT0).NE.9))GOTO 10043
          LOADQ0=SEQ(LOAD(LEFTOP,REGS),DIVABY(TMEMA0(RIGHT0+3),3))
          RETURN
10043   OPREG=:002000
        PREP=GENGE0(105)
        OPSIZE=1
        OPINS=15
      GOTO 10041
10044   IF((TMEMA0(RIGHT0).NE.9))GOTO 10045
          LOADQ0=SEQ(LOAD(LEFTOP,REGS),DIVLBY(TMEMA0(RIGHT0+3),1))
          RETURN
10045   OPREG=:001000
        PREP=GENGE0(66)
        OPSIZE=2
        OPINS=16
      GOTO 10041
10046   IF((TMEMA0(RIGHT0).NE.9))GOTO 10047
          LOADQ0=SEQ(LOAD(LEFTOP,REGS),DIVLBY(TMEMA0(RIGHT0+3),3))
          RETURN
10047   OPREG=:001000
        PREP=SEQ(GENGE0(33),GENGE0(12))
        OPSIZE=2
        OPINS=16
      GOTO 10041
10048   OPREG=:000400
        PREP=0
        OPSIZE=2
        OPINS=24
      GOTO 10041
10049   OPREG=:000200
        PREP=0
        OPSIZE=4
        OPINS=9
      GOTO 10041
10038 GOTO(10039,10044,10042,10046,10048,10049),AAAAF0
        CALL PANIC('load_div: bad operand mode *i*n.',TMEMA0(EXPR+1))
10041 R=REACH(TMEMA0(EXPR+3),RREGS,RRES,RAD)
      CALL ALLOC0(OPSIZE,TAD)
      L=REACH(TMEMA0(EXPR+2),LREGS,LRES,LAD)
      GOTO 10050
10051   AAAAD0=1
        GOTO 10036
10054   AAAAE0=1
        GOTO 10037
10056   AAAAD0=2
        GOTO 10036
10050 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10058
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10058
      GOTO 10051
10058 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10059
      IF(SAFE(OPREG,RREGS))GOTO 10059
      GOTO 10054
10059 IF(SAFE(OPREG,LREGS))GOTO 10060
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10060
      GOTO 10056
10060 CONTINUE
        AAAAE0=2
        GOTO 10037
10061 CONTINUE
10053 CALL FREET0(TAD)
      REGS=OR(OPREG,OR(LREGS,RREGS))
      RETURN
10036 LOADQ0=SEQ(L,LD(OPREG,LRES,LAD),PREP,R,GENMR(OPINS,RAD))
      GOTO 10062
10037 LOADQ0=SEQ(R,LD(OPREG,RRES,RAD))
      LOADQ0=SEQ(LOADQ0,ST(OPREG,TAD),L,LD(OPREG,LRES,LAD),PREP,GENMR(OP
     *INS,TAD))
      GOTO 10063
10062 GOTO(10053,10053),AAAAD0
      GOTO 10062
10063 GOTO(10053,10061),AAAAE0
      GOTO 10063
      END
      INTEGER FUNCTION LOADS0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      INTEGER CAD(5)
      INTEGER MKLAB0
      INTEGER SEQ,GENLA0,GENMR,GENGE0,VOID,FLOW
      INTEGER CREGS
      IF((BREAK0+1.LE.10))GOTO 10064
        CALL PANIC('do loops nested too deeply: break stack overflow*n.'
     *)
10064 BREAK0=BREAK0+(1)
      BREAL0(BREAK0)=MKLAB0(1)
      IF((CONTI0+1.LE.10))GOTO 10065
        CALL PANIC('do loops nested too deeply: continue stack overflow*
     *n.')
10065 CONTI0=CONTI0+(1)
      CONTJ0(CONTI0)=MKLAB0(1)
      IF((TMEMA0(EXPR+2).NE.0))GOTO 10066
        CAD(1)=10
        CAD(3)=CONTJ0(CONTI0)
        LOADS0=SEQ(GENLA0(CAD(3)),VOID(TMEMA0(EXPR+1),REGS),GENMR(32,CAD
     *),GENGE0(19),GENLA0(BREAL0(BREAK0)))
        GOTO 10067
10066   CAD(1)=10
        CAD(3)=MKLAB0(1)
        LOADS0=SEQ(GENLA0(CAD(3)),VOID(TMEMA0(EXPR+1),REGS),GENLA0(CONTJ
     *0(CONTI0)))
        LOADS0=SEQ(LOADS0,FLOW(TMEMA0(EXPR+2),CREGS,.FALSE.,CAD(3)),GENL
     *A0(BREAL0(BREAK0)))
        REGS=OR(REGS,CREGS)
10067 BREAK0=BREAK0-(1)
      CONTI0=CONTI0-(1)
      RETURN
      END
      INTEGER FUNCTION LOADEQ(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      LOGICAL LZERO,RZERO
      LOGICAL SAFE,OPHAS0
      INTEGER L,R
      INTEGER SEQ,REACH,LD,ST,GENGE0,GENMR,LOAD
      INTEGER LREGS,RREGS
      INTEGER LRES,RRES,LAD(5),RAD(5),TAD(5),OPSIZE,OPREG,SUBINS,LOGINS
      INTEGER LEFTOP,RIGHT0
      INTEGER AAAAG0
      INTEGER AAAAH0
      INTEGER AAAAI0
      INTEGER AAAAJ0
      LEFTOP=TMEMA0(EXPR+2)
      RIGHT0=TMEMA0(EXPR+3)
      LZERO=OPHAS0(LEFTOP,0)
      RZERO=OPHAS0(RIGHT0,0)
      AAAAJ0=TMEMA0(EXPR+1)
      GOTO 10071
10072   IF((.NOT.RZERO))GOTO 10073
          LOADEQ=SEQ(LOAD(LEFTOP,REGS),GENGE0(43))
          RETURN
10073   IF((.NOT.LZERO))GOTO 10074
          LOADEQ=SEQ(LOAD(RIGHT0,REGS),GENGE0(43))
          RETURN
10074   OPREG=:002000
        OPSIZE=1
        SUBINS=52
        LOGINS=37
      GOTO 10075
10076   IF((.NOT.RZERO))GOTO 10077
          LOADEQ=SEQ(LOAD(LEFTOP,REGS),GENGE0(55))
          RETURN
10077   IF((.NOT.LZERO))GOTO 10078
          LOADEQ=SEQ(LOAD(RIGHT0,REGS),GENGE0(55))
          RETURN
10078   OPREG=:001000
        OPSIZE=2
        SUBINS=46
        LOGINS=37
      GOTO 10075
10079   IF((.NOT.RZERO))GOTO 10080
          LOADEQ=LOAD(LEFTOP,REGS)
          REGS=OR(REGS,:002000)
          LOADEQ=SEQ(LOADEQ,GENGE0(45))
          RETURN
10080   IF((.NOT.LZERO))GOTO 10081
          LOADEQ=LOAD(RIGHT0,REGS)
          REGS=OR(REGS,:002000)
          LOADEQ=SEQ(LOADEQ,GENGE0(45))
          RETURN
10081   OPREG=:000400
        OPSIZE=2
        SUBINS=28
        LOGINS=45
      GOTO 10075
10082   IF((.NOT.RZERO))GOTO 10083
          LOADEQ=LOAD(LEFTOP,REGS)
          REGS=OR(REGS,:002000)
          LOADEQ=SEQ(LOADEQ,GENGE0(45))
          RETURN
10083   IF((.NOT.LZERO))GOTO 10084
          LOADEQ=LOAD(RIGHT0,REGS)
          REGS=OR(REGS,:002000)
          LOADEQ=SEQ(LOADEQ,GENGE0(45))
          RETURN
10084   OPREG=:000200
        OPSIZE=4
        SUBINS=13
        LOGINS=45
      GOTO 10075
10071 GOTO(10072,10076,10072,10076,10079,10082),AAAAJ0
        CALL PANIC('load_eq: bad op mode *i*n.',TMEMA0(EXPR+1))
10075 R=REACH(TMEMA0(EXPR+3),RREGS,RRES,RAD)
      CALL ALLOC0(OPSIZE,TAD)
      L=REACH(TMEMA0(EXPR+2),LREGS,LRES,LAD)
      GOTO 10085
10086   AAAAG0=1
        GOTO 10068
10089   AAAAH0=1
        GOTO 10069
10091   AAAAG0=2
        GOTO 10068
10085 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10093
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10093
      GOTO 10086
10093 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10094
      IF(SAFE(OPREG,RREGS))GOTO 10094
      GOTO 10089
10094 IF(SAFE(OPREG,LREGS))GOTO 10095
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10095
      GOTO 10091
10095 CONTINUE
        AAAAI0=1
        GOTO 10070
10096 CONTINUE
10088 CALL FREET0(TAD)
      REGS=OR(:002000,OR(OPREG,OR(LREGS,RREGS)))
      RETURN
10068 LOADEQ=SEQ(L,LD(OPREG,LRES,LAD),R,GENMR(SUBINS,RAD),GENGE0(LOGINS)
     *)
      GOTO 10097
10069 LOADEQ=SEQ(R,LD(OPREG,RRES,RAD),L,GENMR(SUBINS,LAD),GENGE0(LOGINS)
     *)
      GOTO 10088
10070 LOADEQ=SEQ(R,LD(OPREG,RRES,RAD))
      LOADEQ=SEQ(LOADEQ,ST(OPREG,TAD),L,LD(OPREG,LRES,LAD),GENMR(SUBINS,
     *TAD),GENGE0(LOGINS))
      GOTO 10096
10097 GOTO(10088,10088),AAAAG0
      GOTO 10097
      END
      INTEGER FUNCTION LOADT0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      INTEGER LDFIE0
      LOADT0=LDFIE0(EXPR,REGS)
      RETURN
      END
      INTEGER FUNCTION LOADV0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      INTEGER AD(5),LOOPL0,TESTL0
      INTEGER MKLAB0
      INTEGER SEQ,GENLA0,GENMR,GENGE0,LOAD,FLOW,VOID
      INTEGER IREGS,CREGS,RREGS,BREGS
      TESTL0=MKLAB0(1)
      LOOPL0=MKLAB0(1)
      IF((BREAK0+1.LE.10))GOTO 10100
        CALL PANIC('for loops nested too deeply: break stack overflow*n.
     *')
10100 BREAK0=BREAK0+(1)
      BREAL0(BREAK0)=MKLAB0(1)
      IF((CONTI0+1.LE.10))GOTO 10101
        CALL PANIC('for loops nested too deeply: continue stack overflow
     **n.')
10101 CONTI0=CONTI0+(1)
      CONTJ0(CONTI0)=MKLAB0(1)
      LOADV0=VOID(TMEMA0(EXPR+1),IREGS)
      AD(1)=10
      IF((TMEMA0(EXPR+2).NE.0))GOTO 10102
        AD(3)=LOOPL0
        LOADV0=SEQ(LOADV0,GENLA0(LOOPL0))
        LOADV0=SEQ(LOADV0,VOID(TMEMA0(EXPR+4),BREGS),GENLA0(CONTJ0(CONTI
     *0)))
        LOADV0=SEQ(LOADV0,VOID(TMEMA0(EXPR+3),RREGS),GENMR(32,AD),GENGE0
     *(19),GENLA0(BREAL0(BREAK0)))
        CREGS=0
        GOTO 10103
10102   AD(3)=TESTL0
        LOADV0=SEQ(LOADV0,GENMR(32,AD),GENGE0(19),GENLA0(LOOPL0))
        LOADV0=SEQ(LOADV0,VOID(TMEMA0(EXPR+4),BREGS),GENLA0(CONTJ0(CONTI
     *0)))
        LOADV0=SEQ(LOADV0,VOID(TMEMA0(EXPR+3),RREGS),GENLA0(TESTL0))
        LOADV0=SEQ(LOADV0,FLOW(TMEMA0(EXPR+2),CREGS,.TRUE.,LOOPL0),GENLA
     *0(BREAL0(BREAK0)))
10103 BREAK0=BREAK0-(1)
      CONTI0=CONTI0-(1)
      REGS=OR(IREGS,OR(CREGS,OR(RREGS,BREGS)))
      RETURN
      END
      INTEGER FUNCTION LOADGE(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      LOGICAL LZERO,RZERO
      LOGICAL SAFE,OPHAS0
      INTEGER L,R
      INTEGER SEQ,REACH,LD,ST,GENGE0,GENMR,GENBR0,GENLA0,LOAD,VOID
      INTEGER LREGS,RREGS
      INTEGER LRES,RRES,LAD(5),RAD(5),TAD(5),OPSIZE,OPREG,SUBINS,LAB
      INTEGER MKLAB0
      INTEGER LEFTOP,RIGHT0
      INTEGER AAAAK0
      INTEGER AAAAL0
      INTEGER AAAAM0
      INTEGER AAAAN0
      INTEGER AAAAO0
      INTEGER AAAAP0
      INTEGER AAAAQ0
      LEFTOP=TMEMA0(EXPR+2)
      RIGHT0=TMEMA0(EXPR+3)
      LZERO=OPHAS0(LEFTOP,0)
      RZERO=OPHAS0(RIGHT0,0)
      AAAAN0=TMEMA0(EXPR+1)
      GOTO 10107
10108   IF((.NOT.RZERO))GOTO 10109
          LOADGE=SEQ(LOAD(LEFTOP,REGS),GENGE0(51))
          RETURN
10109   IF((.NOT.LZERO))GOTO 10110
          LOADGE=SEQ(LOAD(RIGHT0,REGS),GENGE0(54))
          RETURN
10110   OPREG=:002000
        OPSIZE=1
        SUBINS=52
      GOTO 10111
10112   IF((.NOT.RZERO))GOTO 10113
          LOADGE=SEQ(VOID(LEFTOP,REGS),GENGE0(63))
          RETURN
10113   IF((.NOT.LZERO))GOTO 10114
          LOADGE=SEQ(LOAD(RIGHT0,REGS),GENGE0(43))
          RETURN
10114   OPREG=:002000
        OPSIZE=1
        SUBINS=52
      GOTO 10111
10115   IF((.NOT.RZERO))GOTO 10116
          LOADGE=SEQ(LOAD(LEFTOP,REGS),GENGE0(56))
          RETURN
10116   IF((.NOT.LZERO))GOTO 10117
          LOADGE=SEQ(LOAD(RIGHT0,REGS),GENGE0(58))
          RETURN
10117   OPREG=:001000
        OPSIZE=2
        SUBINS=46
      GOTO 10111
10118   IF((.NOT.RZERO))GOTO 10119
          LOADGE=SEQ(VOID(LEFTOP,REGS),GENGE0(63))
          RETURN
10119   IF((.NOT.LZERO))GOTO 10120
          LOADGE=SEQ(LOAD(RIGHT0,REGS),GENGE0(55))
          RETURN
10120   OPREG=:001000
        OPSIZE=2
        SUBINS=46
      GOTO 10111
10121   IF((.NOT.RZERO))GOTO 10122
          LOADGE=LOAD(LEFTOP,REGS)
          REGS=OR(REGS,:002000)
          LOADGE=SEQ(LOADGE,GENGE0(46))
          RETURN
10122   IF((.NOT.LZERO))GOTO 10123
          LOADGE=LOAD(RIGHT0,REGS)
          REGS=OR(REGS,:002000)
          LOADGE=SEQ(LOADGE,GENGE0(48))
          RETURN
10123   OPREG=:000400
        OPSIZE=2
        SUBINS=28
      GOTO 10111
10124   IF((.NOT.RZERO))GOTO 10125
          LOADGE=LOAD(LEFTOP,REGS)
          REGS=OR(REGS,:002000)
          LOADGE=SEQ(LOADGE,GENGE0(46))
          RETURN
10125   IF((.NOT.LZERO))GOTO 10126
          LOADGE=LOAD(RIGHT0,REGS)
          REGS=OR(REGS,:002000)
          LOADGE=SEQ(LOADGE,GENGE0(48))
          RETURN
10126   OPREG=:000200
        OPSIZE=4
        SUBINS=13
      GOTO 10111
10107 GOTO(10108,10115,10112,10118,10121,10124),AAAAN0
        CALL PANIC('load_ge: bad op mode *i*n.',TMEMA0(EXPR+1))
10111 R=REACH(TMEMA0(EXPR+3),RREGS,RRES,RAD)
      CALL ALLOC0(OPSIZE,TAD)
      L=REACH(TMEMA0(EXPR+2),LREGS,LRES,LAD)
      LAB=MKLAB0(1)
      GOTO 10127
10128   AAAAK0=1
        GOTO 10104
10131   AAAAL0=1
        GOTO 10105
10133   AAAAK0=2
        GOTO 10104
10127 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10135
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10135
      GOTO 10128
10135 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10136
      IF(SAFE(OPREG,RREGS))GOTO 10136
      GOTO 10131
10136 IF(SAFE(OPREG,LREGS))GOTO 10137
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10137
      GOTO 10133
10137 CONTINUE
        AAAAM0=1
        GOTO 10106
10138 CONTINUE
10130 CALL FREET0(TAD)
      REGS=OR(:002000,OR(OPREG,OR(LREGS,RREGS)))
      RETURN
10104 LOADGE=SEQ(L,LD(OPREG,LRES,LAD),R,GENMR(SUBINS,RAD))
      AAAAO0=TMEMA0(EXPR+1)
      GOTO 10139
10140   LOADGE=SEQ(LOADGE,GENGE0(38))
      GOTO 10144
10142   LOADGE=SEQ(LOADGE,GENGE0(9),GENBR0(36,LAB),GENGE0(63),GENLA0(LAB
     *))
      GOTO 10144
10143   LOADGE=SEQ(LOADGE,GENGE0(46))
      GOTO 10144
10139 GOTO(10140,10140,10142,10142,10143,10143),AAAAO0
10141 GOTO 10144
10105 LOADGE=SEQ(R,LD(OPREG,RRES,RAD),L,GENMR(SUBINS,LAD))
      AAAAP0=TMEMA0(EXPR+1)
      GOTO 10145
10146   LOADGE=SEQ(LOADGE,GENGE0(40))
      GOTO 10130
10148   LOADGE=SEQ(LOADGE,GENGE0(9),GENBR0(34,LAB),GENGE0(63),GENLA0(LAB
     *))
      GOTO 10130
10149   LOADGE=SEQ(LOADGE,GENGE0(48))
      GOTO 10130
10145 GOTO(10146,10146,10148,10148,10149,10149),AAAAP0
10147 GOTO 10130
10106 LOADGE=SEQ(R,LD(OPREG,RRES,RAD))
      LOADGE=SEQ(LOADGE,ST(OPREG,TAD),L,LD(OPREG,LRES,LAD),GENMR(SUBINS,
     *TAD))
      AAAAQ0=TMEMA0(EXPR+1)
      GOTO 10151
10152   LOADGE=SEQ(LOADGE,GENGE0(38))
      GOTO 10138
10154   LOADGE=SEQ(LOADGE,GENGE0(9),GENBR0(36,LAB),GENGE0(63),GENLA0(LAB
     *))
      GOTO 10138
10155   LOADGE=SEQ(LOADGE,GENGE0(46))
      GOTO 10138
10151 GOTO(10152,10152,10154,10154,10155,10155),AAAAQ0
10153 GOTO 10138
10144 GOTO(10130,10130),AAAAK0
      GOTO 10144
      END
      INTEGER FUNCTION LOADW0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      INTEGER GENMR,GENGE0,SEQ
      INTEGER AD(5)
      AD(1)=10
      AD(3)=TMEMA0(EXPR+1)
      LOADW0=SEQ(GENMR(32,AD),GENGE0(19))
      REGS=0
      RETURN
      END
      INTEGER FUNCTION LOADGT(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      LOGICAL LZERO,RZERO
      LOGICAL SAFE,OPHAS0
      INTEGER L,R
      INTEGER SEQ,REACH,LD,ST,GENGE0,GENMR,GENBR0,GENLA0,LOAD,VOID
      INTEGER LREGS,RREGS
      INTEGER LRES,RRES,LAD(5),RAD(5),TAD(5),OPSIZE,OPREG,SUBINS,LAB
      INTEGER MKLAB0
      INTEGER LEFTOP,RIGHT0
      INTEGER AAAAR0
      INTEGER AAAAS0
      INTEGER AAAAT0
      INTEGER AAAAU0
      INTEGER AAAAV0
      INTEGER AAAAW0
      INTEGER AAAAX0
      LEFTOP=TMEMA0(EXPR+2)
      RIGHT0=TMEMA0(EXPR+3)
      LZERO=OPHAS0(LEFTOP,0)
      RZERO=OPHAS0(RIGHT0,0)
      AAAAU0=TMEMA0(EXPR+1)
      GOTO 10160
10161   IF((.NOT.RZERO))GOTO 10162
          LOADGT=SEQ(LOAD(LEFTOP,REGS),GENGE0(52))
          RETURN
10162   IF((.NOT.LZERO))GOTO 10163
          LOADGT=SEQ(LOAD(RIGHT0,REGS),GENGE0(61))
          RETURN
10163   OPREG=:002000
        OPSIZE=1
        SUBINS=52
      GOTO 10164
10165   IF((.NOT.RZERO))GOTO 10166
          LOADGT=SEQ(VOID(LEFTOP,REGS),GENGE0(63))
          RETURN
10166   IF((.NOT.LZERO))GOTO 10167
          LOADGT=SEQ(VOID(RIGHT0,REGS),GENGE0(9))
          RETURN
10167   OPREG=:002000
        OPSIZE=1
        SUBINS=52
      GOTO 10164
10168   IF((.NOT.RZERO))GOTO 10169
          LOADGT=SEQ(LOAD(LEFTOP,REGS),GENGE0(57))
          RETURN
10169   IF((.NOT.LZERO))GOTO 10170
          LOADGT=SEQ(LOAD(RIGHT0,REGS),GENGE0(59))
          RETURN
10170   OPREG=:001000
        OPSIZE=2
        SUBINS=46
      GOTO 10164
10171   IF((.NOT.RZERO))GOTO 10172
          LOADGT=SEQ(VOID(LEFTOP,REGS),GENGE0(63))
          RETURN
10172   IF((.NOT.LZERO))GOTO 10173
          LOADGT=SEQ(VOID(RIGHT0,REGS),GENGE0(9))
          RETURN
10173   OPREG=:001000
        OPSIZE=2
        SUBINS=46
      GOTO 10164
10174   IF((.NOT.RZERO))GOTO 10175
          LOADGT=LOAD(LEFTOP,REGS)
          REGS=OR(REGS,:002000)
          LOADGT=SEQ(LOADGT,GENGE0(47))
          RETURN
10175   IF((.NOT.LZERO))GOTO 10176
          LOADGT=LOAD(RIGHT0,REGS)
          REGS=OR(REGS,:002000)
          LOADGT=SEQ(LOADGT,GENGE0(49))
          RETURN
10176   OPREG=:000400
        OPSIZE=2
        SUBINS=28
      GOTO 10164
10177   IF((.NOT.RZERO))GOTO 10178
          LOADGT=LOAD(LEFTOP,REGS)
          REGS=OR(REGS,:002000)
          LOADGT=SEQ(LOADGT,GENGE0(47))
          RETURN
10178   IF((.NOT.LZERO))GOTO 10179
          LOADGT=LOAD(RIGHT0,REGS)
          REGS=OR(REGS,:002000)
          LOADGT=SEQ(LOADGT,GENGE0(49))
          RETURN
10179   OPREG=:000200
        OPSIZE=4
        SUBINS=13
      GOTO 10164
10160 GOTO(10161,10168,10165,10171,10174,10177),AAAAU0
        CALL PANIC('load_gt: bad op mode *i*n.',TMEMA0(EXPR+1))
10164 R=REACH(TMEMA0(EXPR+3),RREGS,RRES,RAD)
      CALL ALLOC0(OPSIZE,TAD)
      L=REACH(TMEMA0(EXPR+2),LREGS,LRES,LAD)
      LAB=MKLAB0(1)
      GOTO 10180
10181   AAAAR0=1
        GOTO 10157
10184   AAAAS0=1
        GOTO 10158
10186   AAAAR0=2
        GOTO 10157
10180 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10188
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10188
      GOTO 10181
10188 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10189
      IF(SAFE(OPREG,RREGS))GOTO 10189
      GOTO 10184
10189 IF(SAFE(OPREG,LREGS))GOTO 10190
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10190
      GOTO 10186
10190 CONTINUE
        AAAAT0=1
        GOTO 10159
10191 CONTINUE
10183 CALL FREET0(TAD)
      REGS=OR(:002000,OR(OPREG,OR(LREGS,RREGS)))
      RETURN
10157 LOADGT=SEQ(L,LD(OPREG,LRES,LAD),R,GENMR(SUBINS,RAD))
      AAAAV0=TMEMA0(EXPR+1)
      GOTO 10192
10193   LOADGT=SEQ(LOADGT,GENGE0(39))
      GOTO 10197
10195   LOADGT=SEQ(LOADGT,GENGE0(9),GENBR0(35,LAB),GENGE0(63),GENLA0(LAB
     *))
      GOTO 10197
10196   LOADGT=SEQ(LOADGT,GENGE0(47))
      GOTO 10197
10192 GOTO(10193,10193,10195,10195,10196,10196),AAAAV0
10194 GOTO 10197
10158 LOADGT=SEQ(R,LD(OPREG,RRES,RAD),L,GENMR(SUBINS,LAD))
      AAAAW0=TMEMA0(EXPR+1)
      GOTO 10198
10199   LOADGT=SEQ(LOADGT,GENGE0(41))
      GOTO 10183
10201   LOADGT=SEQ(LOADGT,GENGE0(9),GENBR0(33,LAB),GENGE0(63),GENLA0(LAB
     *))
      GOTO 10183
10202   LOADGT=SEQ(LOADGT,GENGE0(49))
      GOTO 10183
10198 GOTO(10199,10199,10201,10201,10202,10202),AAAAW0
10200 GOTO 10183
10159 LOADGT=SEQ(R,LD(OPREG,RRES,RAD))
      LOADGT=SEQ(LOADGT,ST(OPREG,TAD),L,LD(OPREG,LRES,LAD),GENMR(SUBINS,
     *TAD))
      AAAAX0=TMEMA0(EXPR+1)
      GOTO 10204
10205   LOADGT=SEQ(LOADGT,GENGE0(39))
      GOTO 10191
10207   LOADGT=SEQ(LOADGT,GENGE0(9),GENBR0(35,LAB),GENGE0(63),GENLA0(LAB
     *))
      GOTO 10191
10208   LOADGT=SEQ(LOADGT,GENGE0(47))
      GOTO 10191
10204 GOTO(10205,10205,10207,10207,10208,10208),AAAAX0
10206 GOTO 10191
10197 GOTO(10183,10183),AAAAR0
      GOTO 10197
      END
      INTEGER FUNCTION LOADIF(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      INTEGER LOAD,FLOW,GENGE0,GENMR,GENLA0,SEQ
      INTEGER ELSEL0,EXITL0,AD(5)
      INTEGER MKLAB0
      INTEGER CREGS,TREGS,EREGS
      IF((TMEMA0(EXPR+4).NE.0))GOTO 10210
        EXITL0=MKLAB0(1)
        LOADIF=FLOW(TMEMA0(EXPR+2),CREGS,.FALSE.,EXITL0)
        LOADIF=SEQ(LOADIF,LOAD(TMEMA0(EXPR+3),TREGS),GENLA0(EXITL0))
        EREGS=0
        GOTO 10211
10210   IF((TMEMA0(EXPR+3).NE.0))GOTO 10212
          EXITL0=MKLAB0(1)
          LOADIF=FLOW(TMEMA0(EXPR+2),CREGS,.TRUE.,EXITL0)
          LOADIF=SEQ(LOADIF,LOAD(TMEMA0(EXPR+4),EREGS),GENLA0(EXITL0))
          TREGS=0
          GOTO 10213
10212     ELSEL0=MKLAB0(1)
          EXITL0=MKLAB0(1)
          AD(1)=10
          AD(3)=EXITL0
          LOADIF=FLOW(TMEMA0(EXPR+2),CREGS,.FALSE.,ELSEL0)
          LOADIF=SEQ(LOADIF,LOAD(TMEMA0(EXPR+3),TREGS),GENMR(32,AD),GENG
     *E0(19),GENLA0(ELSEL0))
          LOADIF=SEQ(LOADIF,LOAD(TMEMA0(EXPR+4),EREGS),GENLA0(EXITL0))
10213 CONTINUE
10211 REGS=OR(CREGS,OR(TREGS,EREGS))
      RETURN
      END
      INTEGER FUNCTION LOADX0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      INTEGER REACH,GENMR,LD,SEQ
      INTEGER RES,AD(5)
      INTEGER OPREG
      INTEGER AAAAY0
      LOADX0=REACH(EXPR,REGS,RES,AD)
      AAAAY0=TMEMA0(EXPR+1)
      GOTO 10214
10215   OPREG=:002000
      GOTO 10216
10217   OPREG=:001000
      GOTO 10216
10218   OPREG=:000400
      GOTO 10216
10219   OPREG=:000200
      GOTO 10216
10214 GOTO(10215,10217,10215,10217,10218,10219),AAAAY0
        CALL PANIC('load_index: bad data mode *i*n.',TMEMA0(EXPR+1))
10216 LOADX0=SEQ(LOADX0,LD(OPREG,RES,AD))
      REGS=OR(REGS,OPREG)
      RETURN
      END
      INTEGER FUNCTION LOADY0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      INTEGER GENLA0
      LOADY0=GENLA0(TMEMA0(EXPR+1))
      REGS=0
      RETURN
      END
      INTEGER FUNCTION LOADLE(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      LOGICAL LZERO,RZERO
      LOGICAL SAFE,OPHAS0
      INTEGER L,R
      INTEGER SEQ,REACH,LD,ST,GENGE0,GENMR,GENBR0,GENLA0,LOAD,VOID
      INTEGER LREGS,RREGS
      INTEGER LRES,RRES,LAD(5),RAD(5),TAD(5),OPSIZE,OPREG,SUBINS,LAB
      INTEGER MKLAB0
      INTEGER LEFTOP,RIGHT0
      INTEGER AAAAZ0
      INTEGER AAABA0
      INTEGER AAABB0
      INTEGER AAABC0
      INTEGER AAABD0
      INTEGER AAABE0
      INTEGER AAABF0
      LEFTOP=TMEMA0(EXPR+2)
      RIGHT0=TMEMA0(EXPR+3)
      LZERO=OPHAS0(LEFTOP,0)
      RZERO=OPHAS0(RIGHT0,0)
      AAABC0=TMEMA0(EXPR+1)
      GOTO 10223
10224   IF((.NOT.RZERO))GOTO 10225
          LOADLE=SEQ(LOAD(LEFTOP,REGS),GENGE0(54))
          RETURN
10225   IF((.NOT.LZERO))GOTO 10226
          LOADLE=SEQ(LOAD(RIGHT0,REGS),GENGE0(51))
          RETURN
10226   OPREG=:002000
        OPSIZE=1
        SUBINS=52
      GOTO 10227
10228   IF((.NOT.RZERO))GOTO 10229
          LOADLE=SEQ(LOAD(LEFTOP,REGS),GENGE0(43))
          RETURN
10229   IF((.NOT.LZERO))GOTO 10230
          LOADLE=SEQ(VOID(RIGHT0,REGS),GENGE0(63))
          RETURN
10230   OPREG=:002000
        OPSIZE=1
        SUBINS=52
      GOTO 10227
10231   IF((.NOT.RZERO))GOTO 10232
          LOADLE=SEQ(LOAD(LEFTOP,REGS),GENGE0(58))
          RETURN
10232   IF((.NOT.LZERO))GOTO 10233
          LOADLE=SEQ(LOAD(RIGHT0,REGS),GENGE0(56))
          RETURN
10233   OPREG=:001000
        OPSIZE=2
        SUBINS=46
      GOTO 10227
10234   IF((.NOT.RZERO))GOTO 10235
          LOADLE=SEQ(LOAD(LEFTOP,REGS),GENGE0(55))
          RETURN
10235   IF((.NOT.LZERO))GOTO 10236
          LOADLE=SEQ(VOID(RIGHT0,REGS),GENGE0(63))
          RETURN
10236   OPREG=:001000
        OPSIZE=2
        SUBINS=46
      GOTO 10227
10237   IF((.NOT.RZERO))GOTO 10238
          LOADLE=LOAD(LEFTOP,REGS)
          REGS=OR(REGS,:002000)
          LOADLE=SEQ(LOADLE,GENGE0(48))
          RETURN
10238   IF((.NOT.LZERO))GOTO 10239
          LOADLE=LOAD(RIGHT0,REGS)
          REGS=OR(REGS,:002000)
          LOADLE=SEQ(LOADLE,GENGE0(46))
          RETURN
10239   OPREG=:000400
        OPSIZE=2
        SUBINS=28
      GOTO 10227
10240   IF((.NOT.RZERO))GOTO 10241
          LOADLE=LOAD(LEFTOP,REGS)
          REGS=OR(REGS,:002000)
          LOADLE=SEQ(LOADLE,GENGE0(48))
          RETURN
10241   IF((.NOT.LZERO))GOTO 10242
          LOADLE=LOAD(RIGHT0,REGS)
          REGS=OR(REGS,:002000)
          LOADLE=SEQ(LOADLE,GENGE0(46))
          RETURN
10242   OPREG=:000200
        OPSIZE=4
        SUBINS=13
      GOTO 10227
10223 GOTO(10224,10231,10228,10234,10237,10240),AAABC0
        CALL PANIC('load_le: bad op mode *i*n.',TMEMA0(EXPR+1))
10227 R=REACH(TMEMA0(EXPR+3),RREGS,RRES,RAD)
      CALL ALLOC0(OPSIZE,TAD)
      L=REACH(TMEMA0(EXPR+2),LREGS,LRES,LAD)
      LAB=MKLAB0(1)
      GOTO 10243
10244   AAAAZ0=1
        GOTO 10220
10247   AAABA0=1
        GOTO 10221
10249   AAAAZ0=2
        GOTO 10220
10243 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10251
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10251
      GOTO 10244
10251 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10252
      IF(SAFE(OPREG,RREGS))GOTO 10252
      GOTO 10247
10252 IF(SAFE(OPREG,LREGS))GOTO 10253
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10253
      GOTO 10249
10253 CONTINUE
        AAABB0=1
        GOTO 10222
10254 CONTINUE
10246 CALL FREET0(TAD)
      REGS=OR(:002000,OR(OPREG,OR(LREGS,RREGS)))
      RETURN
10220 LOADLE=SEQ(L,LD(OPREG,LRES,LAD),R,GENMR(SUBINS,RAD))
      AAABD0=TMEMA0(EXPR+1)
      GOTO 10255
10256   LOADLE=SEQ(LOADLE,GENGE0(40))
      GOTO 10260
10258   LOADLE=SEQ(LOADLE,GENGE0(9),GENBR0(34,LAB),GENGE0(63),GENLA0(LAB
     *))
      GOTO 10260
10259   LOADLE=SEQ(LOADLE,GENGE0(48))
      GOTO 10260
10255 GOTO(10256,10256,10258,10258,10259,10259),AAABD0
10257 GOTO 10260
10221 LOADLE=SEQ(R,LD(OPREG,RRES,RAD),L,GENMR(SUBINS,LAD))
      AAABE0=TMEMA0(EXPR+1)
      GOTO 10261
10262   LOADLE=SEQ(LOADLE,GENGE0(38))
      GOTO 10246
10264   LOADLE=SEQ(LOADLE,GENGE0(9),GENBR0(36,LAB),GENGE0(63),GENLA0(LAB
     *))
      GOTO 10246
10265   LOADLE=SEQ(LOADLE,GENGE0(46))
      GOTO 10246
10261 GOTO(10262,10262,10264,10264,10265,10265),AAABE0
10263 GOTO 10246
10222 LOADLE=SEQ(R,LD(OPREG,RRES,RAD))
      LOADLE=SEQ(LOADLE,ST(OPREG,TAD),L,LD(OPREG,LRES,LAD),GENMR(SUBINS,
     *TAD))
      AAABF0=TMEMA0(EXPR+1)
      GOTO 10267
10268   LOADLE=SEQ(LOADLE,GENGE0(40))
      GOTO 10254
10270   LOADLE=SEQ(LOADLE,GENGE0(9),GENBR0(34,LAB),GENGE0(63),GENLA0(LAB
     *))
      GOTO 10254
10271   LOADLE=SEQ(LOADLE,GENGE0(48))
      GOTO 10254
10267 GOTO(10268,10268,10270,10270,10271,10271),AAABF0
10269 GOTO 10254
10260 GOTO(10246,10246),AAAAZ0
      GOTO 10260
      END
C ---- Long Name Map ----
C loadcompl                      loadj0
C loadxoraa                      loafg0
C deletelit                      delev0
C enterent                       enter0
C flowfield                      flowf0
C geniplabel                     genip0
C genlabel                       genla0
C loaddiv                        loadq0
C loadlshiftaa                   loaea0
C loadpredec                     loael0
C otg$aentpb                     otg$a0
C Imem                           imema0
C loadrem                        loaep0
C putmoduleheader                putmo0
C enterlit                       enteu0
C generatestaticstuff            geneu0
C loadchecklower                 loadg0
C loaddefinestat                 loado0
C loadreturn                     loaer0
C setupswitch                    setuq0
C gengeneric                     genge0
C linksize                       links0
C loadandaa                      loadd0
C loadobject                     loaeh0
C loadproccall                   loaen0
C loadrefto                      loaeo0
C lookupext                      looku0
C alloctemp                      alloc0
C loadcheckupper                 loadi0
C loadwhileloop                  loafe0
C geniprtr                       geniq0
C loadrshiftaa                   loaet0
C loadseq                        loaex0
C voidswitch                     voidt0
C looplab                        loopl0
C exitlab                        exitl0
C initializelabels               initi0
C loadsub                        loafa0
C clearobj                       cleax0
C deleteext                      delet0
C loadundefinedynm               loafd0
C reachindex                     reack0
C simplify                       simpl0
C stfield                        stfie0
C lfieldmask                     lfiel0
C loadoraa                       loaei0
C otg$dac                        otg$e0
C otg$mref                       otg$m0
C putmoduletrailer               putmp0
C resolveent                     resol0
C clearstack                     cleay0
C enterext                       entes0
C lshiftaby                      lshif0
C putstartdata                   putst0
C Smem                           smema0
C loadconst                      loadk0
C loadmul                        loaeb0
C loadpostinc                    loaek0
C otg$ecb                        otg$g0
C putbranch                      putbr0
C resolvelit                     reson0
C voidfieldasgop                 voidf0
C Tmem                           tmema0
C EmitPMA                        emitp0
C flowswitch                     flowv0
C loadconvert                    loadl0
C loadforloop                    loadv0
C loadsand                       loaev0
C optimize                       optim0
C rsvstack                       rsvst0
C voidaddaa                      voida0
C testlab                        testl0
C gettree                        gettr0
C loadselect                     loaew0
C lookuplab                      lookv0
C otg$endlb                      otg$h0
C otg$rentlb                     otg$r0
C loadnot                        loaef0
C loadpreinc                     loaem0
C otg$rorglb                     otg$t0
C loadlabel                      loady0
C voidpostdec                    voidp0
C framecom                       frame0
C generateprocedures             genet0
C genswitch                      gensw0
C loaddeclarestat                loadm0
C otglabel                       otgla0
C reachobject                    reacl0
C rshiftaby                      rshif0
C Breaksp                        break0
C Stream1                        strea0
C deletelab                      deleu0
C getlitaddr                     getli0
C loadadd                        loada0
C loadcheckrange                 loadh0
C loadsor                        loaez0
C otg$endpb                      otg$i0
C Stream2                        streb0
C gencopy                        genco0
C loadassign                     loade0
C reachseq                       reacn0
C Stream3                        strec0
C enterlab                       entet0
C generateproc                   genes0
C initshfttableids               inits0
C loadfield                      loadt0
C otg$proc                       otg$p0
C otgmisc                        otgmi0
C resolveext                     resom0
C warning                        warni0
C Breakstack                     breal0
C clearent                       clear0
C loadbreak                      loadf0
C loaddivaa                      loadr0
C loadderef                      loadp0
C loadremaa                      loaeq0
C loadrtrip                      loaeu0
C lshiftlby                      lshig0
C otg$brnch                      otg$d0
C stacksize                      stack0
C Continuesp                     conti0
C andawith                       andaw0
C clearlit                       cleaw0
C gensjtolab                     gensk0
C loadxor                        loaff0
C overlap                        overl0
C genbranch                      genbr0
C loadlshift                     loadz0
C reachconst                     reaci0
C Rtrids                         rtrid0
C voidseq                        voids0
C Continuestack                  contj0
C getextaddr                     getex0
C lookupobj                      lookx0
C otg$rorg                       otg$s0
C reachselect                    reacm0
C arshiftaby                     arshi0
C getlabeladdr                   getla0
C loaddoloop                     loads0
C otg$blk                        otg$c0
C rightop                        right0
C initotg                        inito0
C loadand                        loadc0
C loadsubaa                      loafb0
C otg$gen                        otg$l0
C rshiftlby                      rshig0
C gendata                        genda0
C ldfield                        ldfie0
C loadshiftins                   loaey0
C Errors                         error0
C deleteobj                      delew0
C loadrshift                     loaes0
C otg$entlb                      otg$j0
C voidpostinc                    voidq0
C EmitObj                        emito0
C clearext                       cleas0
C flfield                        flfie0
C flowseq                        flowt0
C freetemp                       freet0
C genshift                       gensh0
C otg$orglb                      otg$o0
C otgpseudo                      otgps0
C reachassign                    reach0
C enterobj                       entev0
C loadgoto                       loadw0
C loadmulaa                      loaec0
C loadswitch                     loafc0
C putlabel                       putla0
C gensjforward                   gensj0
C mklabel                        mklab0
C setupframeowner                setup0
C voidpreinc                     voidr0
C Outfile                        outfi0
C elselab                        elsel0
C andlwith                       andlw0
C loadnull                       loaeg0
C otg$entpb                      otg$k0
C reachderef                     reacj0
C Infile                         infil0
C loadneg                        loaed0
C putmisc                        putmi0
C otg$apins                      otg$b0
C putgeneric                     putge0
C clearinstr                     cleat0
C clearlink                      cleav0
C flowconvert                    flowc0
C flowsand                       flows0
C loadfieldasgop                 loadu0
C otg$data                       otg$f0
C otg$xtip                       otg$x0
C putinstr                       putin0
C voidassign                     voidb0
C adequal                        adequ0
C arshiftlby                     arshj0
C loadaddaa                      loadb0
C loadnext                       loaee0
C ophasvalue                     ophas0
C strsave                        strsa0
C clearstr                       cleaz0
C cleartree                      cleba0
C flownot                        flown0
C otg$rslv                       otg$u0
C rsvlink                        rsvli0
C zerolit                        zerol0
C clearlab                       cleau0
C freestack                      frees0
C genextrtr                      genex0
C loadindex                      loadx0
C lookuplit                      lookw0
C otgbranch                      otgbr0
C loadpostdec                    loaej0
C otg$uii                        otg$v0
C afieldmask                     afiel0
C flowsor                        flowu0
C generateentries                gener0
C loaddefinedynm                 loadn0
