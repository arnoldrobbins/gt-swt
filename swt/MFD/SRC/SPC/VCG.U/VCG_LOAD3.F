      INTEGER FUNCTION LOAEA0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      INTEGER RTRPOS(32),RTRTE0(281)
      COMMON /RTR$CM/RTRPOS,RTRTE0
      INTEGER L,R
      INTEGER GENGE0,GENMR,REACH,LD,ST,SEQ,LSHIF0,LSHIG0,LOADU0,LOAEU0
      INTEGER TAD(5),CAD(5),RAD(5),OPREG,RES,RRES,LAD(5),LOOKX0,JUNK,SHI
     *FT
      INTEGER SHIFT0
      INTEGER LEFTOP,RIGHT0
      INTEGER RREGS
      INTEGER AAAAA0
      LEFTOP=TMEMA0(EXPR+2)
      RIGHT0=TMEMA0(EXPR+3)
      IF((TMEMA0(LEFTOP).NE.69))GOTO 10000
        LOAEA0=LOADU0(EXPR,REGS)
        RETURN
10000 AAAAA0=TMEMA0(EXPR+1)
      GOTO 10001
10002   IF((TMEMA0(RIGHT0).NE.9))GOTO 10003
          L=REACH(LEFTOP,REGS,RES,TAD)
          REGS=OR(REGS,:002000)
          LOAEA0=SEQ(L,LD(:002000,RES,TAD),LSHIF0(TMEMA0(RIGHT0+3)),ST(:
     *002000,TAD))
          RETURN
10003   OPREG=:002000
        SHIFT0=RTRID0(5)
        SHIFT=1
      GOTO 10004
10005   IF((TMEMA0(RIGHT0).NE.9))GOTO 10006
          L=REACH(LEFTOP,REGS,RES,TAD)
          REGS=OR(REGS,:001000)
          LOAEA0=SEQ(L,LD(:001000,RES,TAD),LSHIG0(TMEMA0(RIGHT0+3)),ST(:
     *001000,TAD))
          RETURN
10006   OPREG=:001000
        SHIFT0=RTRID0(6)
        SHIFT=2
      GOTO 10004
10001 GOTO(10002,10005,10002,10005),AAAAA0
        CALL PANIC('load_lshiftaa: bad data mode *i*n.',TMEMA0(EXPR+1))
10004 R=LOAEU0(SHIFT,SHIFT0)
      R=SEQ(R,REACH(TMEMA0(EXPR+3),RREGS,RRES,RAD))
      R=SEQ(R,LD(:002000,RRES,RAD),GENGE0(95))
      JUNK=LOOKX0(SHIFT0,TAD)
      L=REACH(TMEMA0(EXPR+2),REGS,RES,LAD)
      REGS=OR(REGS,RREGS)
      L=SEQ(L,LD(OPREG,RES,LAD),GENMR(35,TAD),ST(OPREG,LAD))
      REGS=OR(REGS,:002000)
      LOAEA0=SEQ(R,L)
      RETURN
      END
      INTEGER FUNCTION LOADZ0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      INTEGER RTRPOS(32),RTRTE0(281)
      COMMON /RTR$CM/RTRPOS,RTRTE0
      INTEGER L,R
      INTEGER GENGE0,GENMR,REACH,LD,ST,SEQ,LSHIF0,LOAD,LSHIG0,LOAEU0
      INTEGER TAD(5),CAD(5),RAD(5),OPREG,OPSIZE,RES,RRES,LAD(5),JUNK,SHI
     *FT
      INTEGER LEFTOP,RIGHT0
      INTEGER RREGS
      INTEGER SHIFT0
      INTEGER AAAAB0
      LEFTOP=TMEMA0(EXPR+2)
      RIGHT0=TMEMA0(EXPR+3)
      AAAAB0=TMEMA0(EXPR+1)
      GOTO 10007
10008   IF((TMEMA0(RIGHT0).NE.9))GOTO 10009
          LOADZ0=SEQ(LOAD(LEFTOP,REGS),LSHIF0(TMEMA0(RIGHT0+3)))
          RETURN
10009   OPREG=:002000
        SHIFT0=RTRID0(5)
        SHIFT=1
      GOTO 10010
10011   IF((TMEMA0(RIGHT0).NE.9))GOTO 10012
          LOADZ0=SEQ(LOAD(LEFTOP,REGS),LSHIG0(TMEMA0(RIGHT0+3)))
          RETURN
10012   OPREG=:001000
        SHIFT0=RTRID0(6)
        SHIFT=2
      GOTO 10010
10007 GOTO(10008,10011,10008,10011),AAAAB0
        CALL PANIC('load_lshift: bad data mode *i*n.',TMEMA0(EXPR+1))
10010 R=LOAEU0(SHIFT,SHIFT0)
      R=SEQ(R,REACH(TMEMA0(EXPR+3),RREGS,RRES,RAD))
      R=SEQ(R,LD(:002000,RRES,RAD),GENGE0(95))
      JUNK=LOOKX0(SHIFT0,TAD)
      L=REACH(TMEMA0(EXPR+2),REGS,RES,LAD)
      REGS=OR(REGS,RREGS)
      L=SEQ(L,LD(OPREG,RES,LAD),GENMR(35,TAD))
      REGS=OR(REGS,:002000)
      LOADZ0=SEQ(R,L)
      RETURN
      END
      INTEGER FUNCTION LOADLT(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      LOGICAL LZERO,RZERO
      LOGICAL SAFE,OPHAS0
      INTEGER L,R
      INTEGER SEQ,REACH,LD,ST,GENGE0,GENMR,GENBR0,GENLA0,LOAD,VOID
      INTEGER LREGS,RREGS
      INTEGER LRES,RRES,LAD(5),RAD(5),TAD(5),OPSIZE,OPREG,SUBINS,LAB
      INTEGER MKLAB0
      INTEGER LEFTOP,RIGHT0
      INTEGER AAAAC0
      INTEGER AAAAD0
      INTEGER AAAAE0
      INTEGER AAAAF0
      INTEGER AAAAG0
      INTEGER AAAAH0
      INTEGER AAAAI0
      LEFTOP=TMEMA0(EXPR+2)
      RIGHT0=TMEMA0(EXPR+3)
      LZERO=OPHAS0(LEFTOP,0)
      RZERO=OPHAS0(RIGHT0,0)
      AAAAF0=TMEMA0(EXPR+1)
      GOTO 10016
10017   IF((.NOT.RZERO))GOTO 10018
          LOADLT=SEQ(LOAD(LEFTOP,REGS),GENGE0(61))
          RETURN
10018   IF((.NOT.LZERO))GOTO 10019
          LOADLT=SEQ(LOAD(RIGHT0,REGS),GENGE0(52))
          RETURN
10019   OPREG=:002000
        OPSIZE=1
        SUBINS=52
      GOTO 10020
10021   IF((.NOT.RZERO))GOTO 10022
          LOADLT=SEQ(VOID(LEFTOP,REGS),GENGE0(9))
          RETURN
10022   IF((.NOT.LZERO))GOTO 10023
          LOADLT=SEQ(VOID(RIGHT0,REGS),GENGE0(63))
          RETURN
10023   OPREG=:002000
        OPSIZE=1
        SUBINS=52
      GOTO 10020
10024   IF((.NOT.RZERO))GOTO 10025
          LOADLT=SEQ(LOAD(LEFTOP,REGS),GENGE0(59))
          RETURN
10025   IF((.NOT.LZERO))GOTO 10026
          LOADLT=SEQ(LOAD(RIGHT0,REGS),GENGE0(57))
          RETURN
10026   OPREG=:001000
        OPSIZE=2
        SUBINS=46
      GOTO 10020
10027   IF((.NOT.RZERO))GOTO 10028
          LOADLT=SEQ(VOID(LEFTOP,REGS),GENGE0(9))
          RETURN
10028   IF((.NOT.LZERO))GOTO 10029
          LOADLT=SEQ(VOID(RIGHT0,REGS),GENGE0(63))
          RETURN
10029   OPREG=:001000
        OPSIZE=2
        SUBINS=46
      GOTO 10020
10030   IF((.NOT.RZERO))GOTO 10031
          LOADLT=LOAD(LEFTOP,REGS)
          REGS=OR(REGS,:002000)
          LOADLT=SEQ(LOADLT,GENGE0(49))
          RETURN
10031   IF((.NOT.LZERO))GOTO 10032
          LOADLT=LOAD(RIGHT0,REGS)
          REGS=OR(REGS,:002000)
          LOADLT=SEQ(LOADLT,GENGE0(47))
          RETURN
10032   OPREG=:000400
        OPSIZE=2
        SUBINS=28
      GOTO 10020
10033   IF((.NOT.RZERO))GOTO 10034
          LOADLT=LOAD(LEFTOP,REGS)
          REGS=OR(REGS,:002000)
          LOADLT=SEQ(LOADLT,GENGE0(49))
          RETURN
10034   IF((.NOT.LZERO))GOTO 10035
          LOADLT=LOAD(RIGHT0,REGS)
          REGS=OR(REGS,:002000)
          LOADLT=SEQ(LOADLT,GENGE0(47))
          RETURN
10035   OPREG=:000200
        OPSIZE=4
        SUBINS=13
      GOTO 10020
10016 GOTO(10017,10024,10021,10027,10030,10033),AAAAF0
        CALL PANIC('load_le: bad op mode *i*n.',TMEMA0(EXPR+1))
10020 R=REACH(TMEMA0(EXPR+3),RREGS,RRES,RAD)
      CALL ALLOC0(OPSIZE,TAD)
      L=REACH(TMEMA0(EXPR+2),LREGS,LRES,LAD)
      LAB=MKLAB0(1)
      GOTO 10036
10037   AAAAC0=1
        GOTO 10013
10040   AAAAD0=1
        GOTO 10014
10042   AAAAC0=2
        GOTO 10013
10036 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10044
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10044
      GOTO 10037
10044 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10045
      IF(SAFE(OPREG,RREGS))GOTO 10045
      GOTO 10040
10045 IF(SAFE(OPREG,LREGS))GOTO 10046
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10046
      GOTO 10042
10046 CONTINUE
        AAAAE0=1
        GOTO 10015
10047 CONTINUE
10039 CALL FREET0(TAD)
      REGS=OR(:002000,OR(OPREG,OR(LREGS,RREGS)))
      RETURN
10013 LOADLT=SEQ(L,LD(OPREG,LRES,LAD),R,GENMR(SUBINS,RAD))
      AAAAG0=TMEMA0(EXPR+1)
      GOTO 10048
10049   LOADLT=SEQ(LOADLT,GENGE0(41))
      GOTO 10053
10051   LOADLT=SEQ(LOADLT,GENGE0(9),GENBR0(33,LAB),GENGE0(63),GENLA0(LAB
     *))
      GOTO 10053
10052   LOADLT=SEQ(LOADLT,GENGE0(49))
      GOTO 10053
10048 GOTO(10049,10049,10051,10051,10052,10052),AAAAG0
10050 GOTO 10053
10014 LOADLT=SEQ(R,LD(OPREG,RRES,RAD),L,GENMR(SUBINS,LAD))
      AAAAH0=TMEMA0(EXPR+1)
      GOTO 10054
10055   LOADLT=SEQ(LOADLT,GENGE0(39))
      GOTO 10039
10057   LOADLT=SEQ(LOADLT,GENGE0(9),GENBR0(35,LAB),GENGE0(63),GENLA0(LAB
     *))
      GOTO 10039
10058   LOADLT=SEQ(LOADLT,GENGE0(47))
      GOTO 10039
10054 GOTO(10055,10055,10057,10057,10058,10058),AAAAH0
10056 GOTO 10039
10015 LOADLT=SEQ(R,LD(OPREG,RRES,RAD))
      LOADLT=SEQ(LOADLT,ST(OPREG,TAD),L,LD(OPREG,LRES,LAD),GENMR(SUBINS,
     *TAD))
      AAAAI0=TMEMA0(EXPR+1)
      GOTO 10060
10061   LOADLT=SEQ(LOADLT,GENGE0(41))
      GOTO 10047
10063   LOADLT=SEQ(LOADLT,GENGE0(9),GENBR0(33,LAB),GENGE0(63),GENLA0(LAB
     *))
      GOTO 10047
10064   LOADLT=SEQ(LOADLT,GENGE0(49))
      GOTO 10047
10060 GOTO(10061,10061,10063,10063,10064,10064),AAAAI0
10062 GOTO 10047
10053 GOTO(10039,10039),AAAAC0
      GOTO 10053
      END
      INTEGER FUNCTION LOAEC0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      LOGICAL SAFE
      INTEGER L,R,CLEAN0
      INTEGER REACH,SEQ,LD,ST,GENGE0,GENMR,MULABY,MULLBY,LOADU0
      INTEGER LRES,RRES,LAD(5),RAD(5),TAD(5),OPINS,OPSIZE
      INTEGER RREGS,LREGS,OPREG
      INTEGER LEFTOP,RIGHT0
      INTEGER AAAAJ0
      INTEGER AAAAK0
      INTEGER AAAAL0
      INTEGER AAAAM0
      LEFTOP=TMEMA0(EXPR+2)
      RIGHT0=TMEMA0(EXPR+3)
      IF((TMEMA0(LEFTOP).NE.69))GOTO 10069
        LOAEC0=LOADU0(EXPR,REGS)
        RETURN
10069 AAAAM0=TMEMA0(EXPR+1)
      GOTO 10070
10071   IF((TMEMA0(RIGHT0).NE.9))GOTO 10072
          L=REACH(LEFTOP,REGS,LRES,LAD)
          REGS=OR(REGS,:002000)
          LOAEC0=SEQ(L,LD(:002000,LRES,LAD),MULABY(TMEMA0(RIGHT0+3)),ST(
     *:002000,LAD))
          RETURN
10072   OPSIZE=1
        OPINS=43
        OPREG=:002000
        CLEAN0=GENGE0(106)
      GOTO 10073
10074   IF((TMEMA0(RIGHT0).NE.9))GOTO 10075
          L=REACH(LEFTOP,REGS,LRES,LAD)
          REGS=OR(REGS,:001000)
          LOAEC0=SEQ(L,LD(:001000,LRES,LAD),MULLBY(TMEMA0(RIGHT0+3)),ST(
     *:001000,LAD))
          RETURN
10075   OPSIZE=2
        OPINS=42
        OPREG=:001000
        CLEAN0=GENGE0(33)
      GOTO 10073
10076   OPSIZE=2
        OPINS=27
        OPREG=:000400
        CLEAN0=0
      GOTO 10073
10077   OPSIZE=4
        OPINS=12
        OPREG=:000200
        CLEAN0=0
      GOTO 10073
10070 GOTO(10071,10074,10071,10074,10076,10077),AAAAM0
        CALL PANIC('load_mulaa: bad data mode *i*n.',TMEMA0(EXPR+1))
10073 R=REACH(TMEMA0(EXPR+3),RREGS,RRES,RAD)
      CALL ALLOC0(OPSIZE,TAD)
      L=REACH(TMEMA0(EXPR+2),LREGS,LRES,LAD)
      GOTO 10078
10079   IF((.NOT.SAFE(LREGS,RREGS)))GOTO 10080
          AAAAJ0=1
          GOTO 10066
10080     AAAAK0=1
          GOTO 10067
10083   CONTINUE
10082 GOTO 10084
10085   AAAAK0=2
        GOTO 10067
10087   IF((.NOT.SAFE(LREGS,RREGS)))GOTO 10088
          AAAAJ0=2
          GOTO 10066
10088     AAAAL0=1
          GOTO 10068
10091   CONTINUE
10090 GOTO 10084
10078 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10092
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10092
      GOTO 10079
10092 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10093
      IF(SAFE(OPREG,RREGS))GOTO 10093
      GOTO 10085
10093 IF(SAFE(OPREG,LREGS))GOTO 10094
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10094
      GOTO 10087
10094 CONTINUE
        AAAAL0=2
        GOTO 10068
10095 CONTINUE
10084 CALL FREET0(TAD)
      REGS=OR(OPREG,OR(LREGS,RREGS))
      RETURN
10066 LOAEC0=SEQ(L,LD(OPREG,LRES,LAD),R,GENMR(OPINS,RAD),CLEAN0,ST(OPREG
     *,LAD))
      GOTO 10096
10067 LOAEC0=SEQ(R,LD(OPREG,RRES,RAD),L,GENMR(OPINS,LAD),CLEAN0,ST(OPREG
     *,LAD))
      GOTO 10097
10068 LOAEC0=SEQ(R,LD(OPREG,RRES,RAD))
      LOAEC0=SEQ(LOAEC0,ST(OPREG,TAD),L,LD(OPREG,LRES,LAD),GENMR(OPINS,T
     *AD),CLEAN0,ST(OPREG,LAD))
      GOTO 10098
10096 GOTO(10084,10084),AAAAJ0
      GOTO 10096
10097 GOTO(10083,10084),AAAAK0
      GOTO 10097
10098 GOTO(10091,10095),AAAAL0
      GOTO 10098
      END
      INTEGER FUNCTION LOAEB0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      LOGICAL SAFE
      INTEGER L,R,CLEAN0
      INTEGER REACH,SEQ,LD,ST,GENGE0,GENMR,MULABY,LOAD,MULLBY
      INTEGER LRES,RRES,LAD(5),RAD(5),TAD(5),OPINS,OPSIZE
      INTEGER RREGS,LREGS,OPREG
      INTEGER RIGHT0,LEFTOP
      INTEGER AAAAN0
      INTEGER AAAAO0
      INTEGER AAAAP0
      INTEGER AAAAQ0
      LEFTOP=TMEMA0(EXPR+2)
      RIGHT0=TMEMA0(EXPR+3)
      AAAAQ0=TMEMA0(EXPR+1)
      GOTO 10102
10103   IF((TMEMA0(RIGHT0).NE.9))GOTO 10104
          LOAEB0=SEQ(LOAD(LEFTOP,REGS),MULABY(TMEMA0(RIGHT0+3)))
          RETURN
10104   IF((TMEMA0(LEFTOP).NE.9))GOTO 10105
          LOAEB0=SEQ(LOAD(RIGHT0,REGS),MULABY(TMEMA0(LEFTOP+3)))
          RETURN
10105   OPSIZE=1
        OPINS=43
        OPREG=:002000
        CLEAN0=GENGE0(106)
      GOTO 10106
10107   IF((TMEMA0(RIGHT0).NE.9))GOTO 10108
          LOAEB0=SEQ(LOAD(LEFTOP,REGS),MULLBY(TMEMA0(RIGHT0+3)))
          RETURN
10108   IF((TMEMA0(LEFTOP).NE.9))GOTO 10109
          LOAEB0=SEQ(LOAD(RIGHT0,REGS),MULLBY(TMEMA0(LEFTOP+3)))
          RETURN
10109   OPSIZE=2
        OPINS=42
        OPREG=:001000
        CLEAN0=GENGE0(33)
      GOTO 10106
10110   OPSIZE=2
        OPINS=27
        OPREG=:000400
        CLEAN0=0
      GOTO 10106
10111   OPSIZE=4
        OPINS=12
        OPREG=:000200
        CLEAN0=0
      GOTO 10106
10102 GOTO(10103,10107,10103,10107,10110,10111),AAAAQ0
        CALL PANIC('load_mul: bad data mode *i*n.',TMEMA0(EXPR+1))
10106 R=REACH(TMEMA0(EXPR+3),RREGS,RRES,RAD)
      CALL ALLOC0(OPSIZE,TAD)
      L=REACH(TMEMA0(EXPR+2),LREGS,LRES,LAD)
      GOTO 10112
10113   AAAAN0=1
        GOTO 10099
10116   AAAAO0=1
        GOTO 10100
10118   AAAAN0=2
        GOTO 10099
10112 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10120
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10120
      GOTO 10113
10120 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10121
      IF(SAFE(OPREG,RREGS))GOTO 10121
      GOTO 10116
10121 IF(SAFE(OPREG,LREGS))GOTO 10122
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10122
      GOTO 10118
10122 CONTINUE
        AAAAP0=1
        GOTO 10101
10123 CONTINUE
10115 CALL FREET0(TAD)
      REGS=OR(OPREG,OR(LREGS,RREGS))
      RETURN
10099 LOAEB0=SEQ(L,LD(OPREG,LRES,LAD),R,GENMR(OPINS,RAD),CLEAN0)
      GOTO 10124
10100 LOAEB0=SEQ(R,LD(OPREG,RRES,RAD),L,GENMR(OPINS,LAD),CLEAN0)
      GOTO 10115
10101 LOAEB0=SEQ(R,LD(OPREG,RRES,RAD))
      LOAEB0=SEQ(LOAEB0,ST(OPREG,TAD),L,LD(OPREG,LRES,LAD),GENMR(OPINS,T
     *AD),CLEAN0)
      GOTO 10123
10124 GOTO(10115,10115),AAAAN0
      GOTO 10124
      END
      INTEGER FUNCTION LOAED0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      INTEGER LOAD,GENGE0,SEQ
      INTEGER AAAAR0
      LOAED0=LOAD(TMEMA0(EXPR+2),REGS)
      AAAAR0=TMEMA0(EXPR+1)
      GOTO 10127
10128   LOAED0=SEQ(LOAED0,GENGE0(98))
      GOTO 10129
10130   LOAED0=SEQ(LOAED0,GENGE0(99))
      GOTO 10129
10131   LOAED0=SEQ(LOAED0,GENGE0(17))
      GOTO 10129
10132   LOAED0=SEQ(LOAED0,GENGE0(15))
      GOTO 10129
10127 GOTO(10128,10130,10128,10130,10131,10132),AAAAR0
        CALL PANIC('load_neg: bad data mode *i*n.',TMEMA0(EXPR+1))
10129 RETURN
      END
      INTEGER FUNCTION LOAEE0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      INTEGER LEVEL,LAD(5)
      INTEGER SEQ,GENGE0,GENMR
      LOAEE0=0
      REGS=0
      LEVEL=TMEMA0(EXPR+1)
      IF((LEVEL.GT.CONTI0))GOTO 10134
      IF((LEVEL.LT.1))GOTO 10134
      GOTO 10133
10134   CALL WARNI0('load_next: improper continue level (*i)*n.',LEVEL)
        GOTO 10135
10133   LEVEL=CONTI0-LEVEL+1
        LAD(1)=10
        LAD(3)=CONTJ0(LEVEL)
        LOAEE0=SEQ(GENMR(32,LAD),GENGE0(19))
10135 RETURN
      END
      INTEGER FUNCTION LOADNE(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      LOGICAL LZERO,RZERO
      LOGICAL SAFE,OPHAS0
      INTEGER L,R
      INTEGER SEQ,REACH,LD,ST,GENGE0,GENMR,LOAD
      INTEGER LREGS,RREGS
      INTEGER LRES,RRES,LAD(5),RAD(5),TAD(5),OPSIZE,OPREG,SUBINS,LOGINS
      INTEGER LEFTOP,RIGHT0
      INTEGER AAAAS0
      INTEGER AAAAT0
      INTEGER AAAAU0
      INTEGER AAAAV0
      LEFTOP=TMEMA0(EXPR+2)
      RIGHT0=TMEMA0(EXPR+3)
      LZERO=OPHAS0(LEFTOP,0)
      RZERO=OPHAS0(RIGHT0,0)
      AAAAV0=TMEMA0(EXPR+1)
      GOTO 10139
10140   IF((.NOT.RZERO))GOTO 10141
          LOADNE=SEQ(LOAD(LEFTOP,REGS),GENGE0(62))
          RETURN
10141   IF((.NOT.LZERO))GOTO 10142
          LOADNE=SEQ(LOAD(RIGHT0,REGS),GENGE0(62))
          RETURN
10142   OPREG=:002000
        OPSIZE=1
        SUBINS=52
        LOGINS=42
      GOTO 10143
10144   IF((.NOT.RZERO))GOTO 10145
          LOADNE=SEQ(LOAD(LEFTOP,REGS),GENGE0(60))
          RETURN
10145   IF((.NOT.LZERO))GOTO 10146
          LOADNE=SEQ(LOAD(RIGHT0,REGS),GENGE0(60))
          RETURN
10146   OPREG=:001000
        OPSIZE=2
        SUBINS=46
        LOGINS=42
      GOTO 10143
10147   IF((.NOT.RZERO))GOTO 10148
          LOADNE=LOAD(LEFTOP,REGS)
          REGS=OR(REGS,:002000)
          LOADNE=SEQ(LOADNE,GENGE0(50))
          RETURN
10148   IF((.NOT.LZERO))GOTO 10149
          LOADNE=LOAD(RIGHT0,REGS)
          REGS=OR(REGS,:002000)
          LOADNE=SEQ(LOADNE,GENGE0(50))
          RETURN
10149   OPREG=:000400
        OPSIZE=2
        SUBINS=28
        LOGINS=50
      GOTO 10143
10150   IF((.NOT.RZERO))GOTO 10151
          LOADNE=LOAD(LEFTOP,REGS)
          REGS=OR(REGS,:002000)
          LOADNE=SEQ(LOADNE,GENGE0(50))
          RETURN
10151   IF((.NOT.LZERO))GOTO 10152
          LOADNE=LOAD(RIGHT0,REGS)
          REGS=OR(REGS,:002000)
          LOADNE=SEQ(LOADNE,GENGE0(50))
          RETURN
10152   OPREG=:000200
        OPSIZE=4
        SUBINS=13
        LOGINS=50
      GOTO 10143
10139 GOTO(10140,10144,10140,10144,10147,10150),AAAAV0
        CALL PANIC('load_ne: bad op mode *i*n.',TMEMA0(EXPR+1))
10143 R=REACH(TMEMA0(EXPR+3),RREGS,RRES,RAD)
      CALL ALLOC0(OPSIZE,TAD)
      L=REACH(TMEMA0(EXPR+2),LREGS,LRES,LAD)
      GOTO 10153
10154   AAAAS0=1
        GOTO 10136
10157   AAAAT0=1
        GOTO 10137
10159   AAAAS0=2
        GOTO 10136
10153 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10161
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10161
      GOTO 10154
10161 IF((.NOT.SAFE(OPREG,LREGS)))GOTO 10162
      IF(SAFE(OPREG,RREGS))GOTO 10162
      GOTO 10157
10162 IF(SAFE(OPREG,LREGS))GOTO 10163
      IF((.NOT.SAFE(OPREG,RREGS)))GOTO 10163
      GOTO 10159
10163 CONTINUE
        AAAAU0=1
        GOTO 10138
10164 CONTINUE
10156 CALL FREET0(TAD)
      REGS=OR(:002000,OR(OPREG,OR(LREGS,RREGS)))
      RETURN
10136 LOADNE=SEQ(L,LD(OPREG,LRES,LAD),R,GENMR(SUBINS,RAD),GENGE0(LOGINS)
     *)
      GOTO 10165
10137 LOADNE=SEQ(R,LD(OPREG,RRES,RAD),L,GENMR(SUBINS,LAD),GENGE0(LOGINS)
     *)
      GOTO 10156
10138 LOADNE=SEQ(R,LD(OPREG,RRES,RAD))
      LOADNE=SEQ(LOADNE,ST(OPREG,TAD),L,LD(OPREG,LRES,LAD),GENMR(SUBINS,
     *TAD),GENGE0(LOGINS))
      GOTO 10164
10165 GOTO(10156,10156),AAAAS0
      GOTO 10165
      END
      INTEGER FUNCTION LOAEF0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      INTEGER LOAD,GENGE0,SEQ
      INTEGER AAAAW0
      LOAEF0=LOAD(TMEMA0(EXPR+2),REGS)
      REGS=OR(REGS,:002000)
      AAAAW0=TMEMA0(EXPR+1)
      GOTO 10168
10169   LOAEF0=SEQ(LOAEF0,GENGE0(43))
      GOTO 10170
10171   LOAEF0=SEQ(LOAEF0,GENGE0(55))
      GOTO 10170
10172   LOAEF0=SEQ(LOAEF0,GENGE0(45))
      GOTO 10170
10168 GOTO(10169,10171,10169,10171,10172,10172),AAAAW0
        CALL PANIC('load_not: bad data mode *i*n.',TMEMA0(EXPR+1))
10170 RETURN
      END
      INTEGER FUNCTION LOAEG0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      REGS=0
      LOAEG0=0
      RETURN
      END
      INTEGER FUNCTION LOAEH0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      INTEGER GENMR
      INTEGER RES,AD(5)
      INTEGER AAAAX0
      CALL REACH(EXPR,REGS,RES,AD)
      AAAAX0=TMEMA0(EXPR+1)
      GOTO 10173
10174   LOAEH0=GENMR(37,AD)
        REGS=OR(REGS,:002000)
      GOTO 10175
10176   LOAEH0=GENMR(38,AD)
        REGS=OR(REGS,:001000)
      GOTO 10175
10177   LOAEH0=GENMR(25,AD)
        REGS=OR(REGS,:000400)
      GOTO 10175
10178   LOAEH0=GENMR(10,AD)
        REGS=OR(REGS,:000200)
      GOTO 10175
10173 GOTO(10174,10176,10174,10176,10177,10178),AAAAX0
        CALL PANIC('load_object: bad mode *i*n.',TMEMA0(EXPR+1))
10175 RETURN
      END
      INTEGER FUNCTION LOAEI0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      LOGICAL SAFE
      INTEGER LREGS,RREGS
      INTEGER LRES,RRES,LAD(5),RAD(5),OPSIZE,TAD(5)
      INTEGER L,R
      INTEGER SEQ,GENMR,LD,ST,REACH,GENGE0,LOADU0
      INTEGER AAAAY0
      INTEGER AAAAZ0
      INTEGER AAABA0
      INTEGER AAABB0
      INTEGER AAABC0
      INTEGER AAABD0
      INTEGER AAABE0
      IF((TMEMA0(TMEMA0(EXPR+2)).NE.69))GOTO 10185
        LOAEI0=LOADU0(EXPR,REGS)
        RETURN
10185 R=REACH(TMEMA0(EXPR+3),RREGS,RRES,RAD)
      CALL ALLOC0(2,TAD)
      L=REACH(TMEMA0(EXPR+2),LREGS,LRES,LAD)
      AAABE0=TMEMA0(EXPR+1)
      GOTO 10186
10189     IF((.NOT.SAFE(LREGS,RREGS)))GOTO 10190
            AAAAY0=1
            GOTO 10179
10190       AAAAZ0=1
            GOTO 10180
10193     CONTINUE
10192   GOTO 10206
10195     AAAAZ0=2
          GOTO 10180
10197     IF((.NOT.SAFE(LREGS,RREGS)))GOTO 10198
            AAAAY0=2
            GOTO 10179
10198       AAABA0=1
            GOTO 10181
10201     CONTINUE
10200   GOTO 10206
10188   IF((.NOT.SAFE(:002000,LREGS)))GOTO 10202
        IF((.NOT.SAFE(:002000,RREGS)))GOTO 10202
        GOTO 10189
10202   IF((.NOT.SAFE(:002000,LREGS)))GOTO 10203
        IF(SAFE(:002000,RREGS))GOTO 10203
        GOTO 10195
10203   IF(SAFE(:002000,LREGS))GOTO 10204
        IF((.NOT.SAFE(:002000,RREGS)))GOTO 10204
        GOTO 10197
10204   CONTINUE
          AAABA0=2
          GOTO 10181
10205   CONTINUE
10194 GOTO 10206
10207   IF((RRES.NE.1))GOTO 10208
          AAABB0=1
          GOTO 10182
10208     IF((RAD(1).NE.7))GOTO 10211
            AAABC0=1
            GOTO 10183
10211       IF((RAD(1).NE.1))GOTO 10214
            IF((.NOT.SAFE(OR(LREGS,:001000),RREGS)))GOTO 10214
              AAABD0=1
              GOTO 10184
10214         IF((RAD(1).NE.2))GOTO 10217
              IF((.NOT.SAFE(OR(LREGS,:001000),RREGS)))GOTO 10217
                AAABD0=2
                GOTO 10184
10217           AAABB0=2
                GOTO 10182
10220         CONTINUE
10219       CONTINUE
10216     CONTINUE
10213   CONTINUE
10210 GOTO 10206
10186 GOTO(10188,10207,10188,10207),AAABE0
        CALL PANIC('load_oraa: bad data mode *i*n.',TMEMA0(EXPR+1))
10206 CALL FREET0(TAD)
      REGS=OR(:002000,OR(LREGS,RREGS))
      RETURN
10179 LOAEI0=SEQ(L,LD(:002000,LRES,LAD),R,GENMR(44,RAD),ST(:002000,LAD))
      GOTO 10221
10180 LOAEI0=SEQ(R,LD(:002000,RRES,RAD),L,GENMR(44,LAD),ST(:002000,LAD))
      GOTO 10222
10181 LOAEI0=SEQ(R,LD(:002000,RRES,RAD))
      LOAEI0=SEQ(LOAEI0,ST(:002000,TAD),L,LD(:002000,LRES,LAD),GENMR(44,
     *TAD),ST(:002000,LAD))
      GOTO 10223
10182 LOAEI0=SEQ(R,LD(:001000,RRES,RAD),ST(:001000,TAD),L,LD(:001000,LRE
     *S,LAD),GENMR(44,TAD),GENGE0(29))
      TAD(3)=TAD(3)+(1)
      LOAEI0=SEQ(LOAEI0,GENMR(44,TAD),GENGE0(29),ST(:001000,LAD))
      TAD(3)=TAD(3)-(1)
      GOTO 10224
10183 TAD(1)=6
      TAD(2)=RAD(2)
      LOAEI0=SEQ(L,LD(:001000,LRES,LAD),GENMR(44,TAD),GENGE0(29))
      TAD(2)=RAD(3)
      LOAEI0=SEQ(LOAEI0,GENMR(44,TAD),GENGE0(29),ST(:001000,LAD))
      GOTO 10213
10184 LOAEI0=SEQ(L,LD(:001000,LRES,LAD),R,GENMR(44,RAD),GENGE0(29))
      RAD(3)=RAD(3)+(1)
      LOAEI0=SEQ(LOAEI0,GENMR(44,RAD),GENGE0(29),ST(:001000,LAD))
      GOTO 10226
10221 GOTO(10206,10206),AAAAY0
      GOTO 10221
10222 GOTO(10193,10206),AAAAZ0
      GOTO 10222
10223 GOTO(10201,10205),AAABA0
      GOTO 10223
10224 GOTO(10206,10220),AAABB0
      GOTO 10224
10226 GOTO(10216,10219),AAABD0
      GOTO 10226
      END
      INTEGER FUNCTION LOADOR(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      LOGICAL SAFE
      INTEGER LREGS,RREGS
      INTEGER LRES,RRES,LAD(5),RAD(5),OPSIZE,TAD(5)
      INTEGER L,R
      INTEGER SEQ,GENMR,LD,ST,REACH,GENGE0
      INTEGER AAABF0
      INTEGER AAABG0
      INTEGER AAABH0
      INTEGER AAABI0
      INTEGER AAABJ0
      INTEGER AAABK0
      INTEGER AAABL0
      R=REACH(TMEMA0(EXPR+3),RREGS,RRES,RAD)
      CALL ALLOC0(2,TAD)
      L=REACH(TMEMA0(EXPR+2),LREGS,LRES,LAD)
      AAABL0=TMEMA0(EXPR+1)
      GOTO 10233
10236     AAABF0=1
          GOTO 10227
10239     AAABG0=1
          GOTO 10228
10241     AAABF0=2
          GOTO 10227
10235   IF((.NOT.SAFE(:002000,LREGS)))GOTO 10243
        IF((.NOT.SAFE(:002000,RREGS)))GOTO 10243
        GOTO 10236
10243   IF((.NOT.SAFE(:002000,LREGS)))GOTO 10244
        IF(SAFE(:002000,RREGS))GOTO 10244
        GOTO 10239
10244   IF(SAFE(:002000,LREGS))GOTO 10245
        IF((.NOT.SAFE(:002000,RREGS)))GOTO 10245
        GOTO 10241
10245   CONTINUE
          AAABH0=1
          GOTO 10229
10246   CONTINUE
10238 GOTO 10247
10248   IF((RRES.NE.1))GOTO 10249
          AAABI0=1
          GOTO 10230
10249     IF((RAD(1).NE.7))GOTO 10252
            AAABJ0=1
            GOTO 10231
10252       IF((RAD(1).NE.1))GOTO 10255
            IF((.NOT.SAFE(:001000,RREGS)))GOTO 10255
              AAABK0=1
              GOTO 10232
10255         IF((RAD(1).NE.2))GOTO 10258
              IF((.NOT.SAFE(:001000,RREGS)))GOTO 10258
                AAABK0=2
                GOTO 10232
10258           AAABI0=2
                GOTO 10230
10261         CONTINUE
10260       CONTINUE
10257     CONTINUE
10254   CONTINUE
10251 GOTO 10247
10233 GOTO(10235,10248,10235,10248),AAABL0
        CALL PANIC('load_or: bad data mode *i*n.',TMEMA0(EXPR+1))
10247 CALL FREET0(TAD)
      REGS=OR(:002000,OR(LREGS,RREGS))
      RETURN
10227 LOADOR=SEQ(L,LD(:002000,LRES,LAD),R,GENMR(44,RAD))
      GOTO 10262
10228 LOADOR=SEQ(R,LD(:002000,RRES,RAD),L,GENMR(44,LAD))
      GOTO 10247
10229 LOADOR=SEQ(R,LD(:002000,RRES,RAD))
      LOADOR=SEQ(LOADOR,ST(:002000,TAD),L,LD(:002000,LRES,LAD),GENMR(44,
     *TAD))
      GOTO 10246
10230 LOADOR=SEQ(R,LD(:001000,RRES,RAD),ST(:001000,TAD),L,LD(:001000,LRE
     *S,LAD),GENMR(44,TAD),GENGE0(29))
      TAD(3)=TAD(3)+(1)
      LOADOR=SEQ(LOADOR,GENMR(44,TAD),GENGE0(29))
      TAD(3)=TAD(3)-(1)
      GOTO 10265
10231 TAD(1)=6
      TAD(2)=RAD(2)
      LOADOR=SEQ(L,LD(:001000,LRES,LAD),GENMR(44,TAD),GENGE0(29))
      TAD(2)=RAD(3)
      LOADOR=SEQ(LOADOR,GENMR(44,TAD),GENGE0(29))
      GOTO 10254
10232 LOADOR=SEQ(L,LD(:001000,LRES,LAD),R,GENMR(44,RAD),GENGE0(29))
      RAD(3)=RAD(3)+(1)
      LOADOR=SEQ(LOADOR,GENMR(44,RAD),GENGE0(29))
      GOTO 10267
10262 GOTO(10247,10247),AAABF0
      GOTO 10262
10265 GOTO(10247,10261),AAABI0
      GOTO 10265
10267 GOTO(10257,10260),AAABK0
      GOTO 10267
      END
      INTEGER FUNCTION LOAEJ0(EXPR,REGS)
      INTEGER EXPR
      INTEGER REGS
      INTEGER IMEMA0(65530),TMEMA0(65000),ERROR0,BREAK0,CONTI0
      INTEGER SMEMA0(32767)
      INTEGER BREAL0(10),CONTJ0(10)
      INTEGER OUTFI0,INFIL0,STREA0,STREB0,STREC0
      INTEGER RTRID0(31)
      INTEGER EMITP0,EMITO0
      COMMON /VCGCOM/ERROR0,BREAK0,CONTI0,BREAL0,CONTJ0,OUTFI0,INFIL0,ST
     *REA0,STREB0,STREC0,RTRID0,EMITP0,EMITO0
      COMMON /VCGCM1/IMEMA0
      COMMON /VCGCM2/TMEMA0
      COMMON /VCGCM3/SMEMA0
      INTEGER LREGS,RREGS,OPREG
      INTEGER L,R
      INTEGER SEQ,LD,ST,GENMR,REACH,LOADU0
      INTEGER LRES,RRES,LAD(5),RAD(5),OPINS,INVINS
      INTEGER MESG(15)
      INTEGER AAABM0
      INTEGER AAABN0
      INTEGER AAABO0
      DATA MESG/236,239,225,228,223,240,239,243,244,228,229,227,186,160,
     *0/
      IF((TMEMA0(TMEMA0(EXPR+2)).NE.69))GOTO 10268
        LOAEJ0=LOADU0(EXPR,REGS)
        RETURN
10268 AAABM0=TMEMA0(EXPR+1)
      GOTO 10269
10270   OPREG=:002000
        OPINS=52
        INVINS=1
      GOTO 10271
10272   OPREG=:001000
        OPINS=46
        INVINS=2
      GOTO 10271
10273   OPREG=:000400
        OPINS=28
        INVINS=22
      GOTO 10271
10274   OPREG=:000200
        OPINS=13
        INVINS=7
      GOTO 10271
10269 GOTO(10270,10272,10270,10272,10273,10274),AAABM0
        CALL WARNI0('*sbad data mode*i*n.',MESG,TMEMA0(EXPR+1))
        REGS=0
        LOAEJ0=0
        RETURN
10271 L=REACH(TMEMA0(EXPR+2),LREGS,LRES,LAD)
      R=REACH(TMEMA0(EXPR+3),RREGS,RRES,RAD)
      IF((RRES.NE.1))GOTO 10275
        CALL WARNI0('*sright op not a constant*n.',MESG)
        REGS=0
        LOAEJ0=0
        RETURN
10275 AAABN0=RAD(1)
      GOTO 10276
10276 AAABO0=AAABN0-5
      GOTO(10278,10278,10278,10278),AAABO0
        CALL WARNI0('*sright op not a constant*n.',MESG)
        REGS=0
        LOAEJ0=0
        RETURN
10278 IF((LRES.NE.1))GOTO 10279
        CALL WARNI0('*sleft op not an lvalue*n.',MESG)
        REGS=0
        LOAEJ0=0
        RETURN
10279 LOAEJ0=SEQ(L,LD(OPREG,LRES,LAD),GENMR(OPINS,RAD),ST(OPREG,LAD),GEN
     *MR(INVINS,RAD))
      REGS=OR(OPREG,LREGS)
      RETURN
      END
C ---- Long Name Map ----
C loadcompl                      loadj0
C loadxoraa                      loafg0
C deletelit                      delev0
C enterent                       enter0
C flowfield                      flowf0
C geniplabel                     genip0
C genlabel                       genla0
C loaddiv                        loadq0
C loadlshiftaa                   loaea0
C loadpredec                     loael0
C otg$aentpb                     otg$a0
C Imem                           imema0
C loadrem                        loaep0
C putmoduleheader                putmo0
C enterlit                       enteu0
C generatestaticstuff            geneu0
C loadchecklower                 loadg0
C loaddefinestat                 loado0
C loadreturn                     loaer0
C setupswitch                    setuq0
C gengeneric                     genge0
C linksize                       links0
C loadandaa                      loadd0
C loadobject                     loaeh0
C loadproccall                   loaen0
C loadrefto                      loaeo0
C lookupext                      looku0
C alloctemp                      alloc0
C loadcheckupper                 loadi0
C loadwhileloop                  loafe0
C cleanup                        clean0
C geniprtr                       geniq0
C loadrshiftaa                   loaet0
C loadseq                        loaex0
C voidswitch                     voidt0
C initializelabels               initi0
C loadsub                        loafa0
C clearobj                       cleax0
C deleteext                      delet0
C loadundefinedynm               loafd0
C reachindex                     reack0
C simplify                       simpl0
C stfield                        stfie0
C shiftid                        shift0
C lfieldmask                     lfiel0
C loadoraa                       loaei0
C otg$dac                        otg$e0
C otg$mref                       otg$m0
C putmoduletrailer               putmp0
C resolveent                     resol0
C clearstack                     cleay0
C enterext                       entes0
C lshiftaby                      lshif0
C putstartdata                   putst0
C Smem                           smema0
C loadconst                      loadk0
C loadmul                        loaeb0
C loadpostinc                    loaek0
C otg$ecb                        otg$g0
C putbranch                      putbr0
C resolvelit                     reson0
C voidfieldasgop                 voidf0
C Tmem                           tmema0
C EmitPMA                        emitp0
C flowswitch                     flowv0
C loadconvert                    loadl0
C loadforloop                    loadv0
C loadsand                       loaev0
C optimize                       optim0
C rsvstack                       rsvst0
C voidaddaa                      voida0
C gettree                        gettr0
C loadselect                     loaew0
C lookuplab                      lookv0
C otg$endlb                      otg$h0
C otg$rentlb                     otg$r0
C loadnot                        loaef0
C loadpreinc                     loaem0
C otg$rorglb                     otg$t0
C loadlabel                      loady0
C voidpostdec                    voidp0
C rtrtext                        rtrte0
C framecom                       frame0
C generateprocedures             genet0
C genswitch                      gensw0
C loaddeclarestat                loadm0
C otglabel                       otgla0
C reachobject                    reacl0
C rshiftaby                      rshif0
C Breaksp                        break0
C Stream1                        strea0
C deletelab                      deleu0
C getlitaddr                     getli0
C loadadd                        loada0
C loadcheckrange                 loadh0
C loadsor                        loaez0
C otg$endpb                      otg$i0
C Stream2                        streb0
C gencopy                        genco0
C loadassign                     loade0
C reachseq                       reacn0
C Stream3                        strec0
C enterlab                       entet0
C generateproc                   genes0
C initshfttableids               inits0
C loadfield                      loadt0
C otg$proc                       otg$p0
C otgmisc                        otgmi0
C resolveext                     resom0
C warning                        warni0
C Breakstack                     breal0
C clearent                       clear0
C loadbreak                      loadf0
C loaddivaa                      loadr0
C loadderef                      loadp0
C loadremaa                      loaeq0
C loadrtrip                      loaeu0
C lshiftlby                      lshig0
C otg$brnch                      otg$d0
C stacksize                      stack0
C Continuesp                     conti0
C andawith                       andaw0
C clearlit                       cleaw0
C gensjtolab                     gensk0
C loadxor                        loaff0
C overlap                        overl0
C genbranch                      genbr0
C loadlshift                     loadz0
C reachconst                     reaci0
C Rtrids                         rtrid0
C voidseq                        voids0
C Continuestack                  contj0
C getextaddr                     getex0
C lookupobj                      lookx0
C otg$rorg                       otg$s0
C reachselect                    reacm0
C arshiftaby                     arshi0
C getlabeladdr                   getla0
C loaddoloop                     loads0
C otg$blk                        otg$c0
C rightop                        right0
C initotg                        inito0
C loadand                        loadc0
C loadsubaa                      loafb0
C otg$gen                        otg$l0
C rshiftlby                      rshig0
C gendata                        genda0
C ldfield                        ldfie0
C loadshiftins                   loaey0
C Errors                         error0
C deleteobj                      delew0
C loadrshift                     loaes0
C otg$entlb                      otg$j0
C voidpostinc                    voidq0
C EmitObj                        emito0
C clearext                       cleas0
C flfield                        flfie0
C flowseq                        flowt0
C freetemp                       freet0
C genshift                       gensh0
C otg$orglb                      otg$o0
C otgpseudo                      otgps0
C reachassign                    reach0
C enterobj                       entev0
C loadgoto                       loadw0
C loadmulaa                      loaec0
C loadswitch                     loafc0
C putlabel                       putla0
C gensjforward                   gensj0
C mklabel                        mklab0
C setupframeowner                setup0
C voidpreinc                     voidr0
C Outfile                        outfi0
C andlwith                       andlw0
C loadnull                       loaeg0
C otg$entpb                      otg$k0
C reachderef                     reacj0
C Infile                         infil0
C loadneg                        loaed0
C putmisc                        putmi0
C otg$apins                      otg$b0
C putgeneric                     putge0
C clearinstr                     cleat0
C clearlink                      cleav0
C flowconvert                    flowc0
C flowsand                       flows0
C loadfieldasgop                 loadu0
C otg$data                       otg$f0
C otg$xtip                       otg$x0
C putinstr                       putin0
C voidassign                     voidb0
C adequal                        adequ0
C arshiftlby                     arshj0
C loadaddaa                      loadb0
C loadnext                       loaee0
C ophasvalue                     ophas0
C strsave                        strsa0
C clearstr                       cleaz0
C cleartree                      cleba0
C flownot                        flown0
C otg$rslv                       otg$u0
C rsvlink                        rsvli0
C zerolit                        zerol0
C clearlab                       cleau0
C freestack                      frees0
C genextrtr                      genex0
C loadindex                      loadx0
C lookuplit                      lookw0
C otgbranch                      otgbr0
C loadpostdec                    loaej0
C otg$uii                        otg$v0
C afieldmask                     afiel0
C flowsor                        flowu0
C generateentries                gener0
C loaddefinedynm                 loadn0
