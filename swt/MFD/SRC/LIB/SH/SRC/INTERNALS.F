      SUBROUTINE ARGCMD
      INTEGER ARG(10)
      INTEGER ARGNO,BACKNO,I
      INTEGER GETARG,CTOI
      INTEGER PTR
      INTEGER ACCES0
      IF((GETARG(1,ARG,10).NE.-1))GOTO 10000
        RETURN
10000   I=1
        ARGNO=CTOI(ARG,I)
      IF((GETARG(2,ARG,10).NE.-1))GOTO 10001
        BACKNO=1
        GOTO 10002
10001   I=1
        BACKNO=CTOI(ARG,I)
10002 PTR=ACCES0(BACKNO,ARGNO)
      IF((PTR.NE.-1))GOTO 10003
        CALL PUTCH(138,-11)
        GOTO 10004
10003   CALL LSPUTF(PTR,-11)
        CALL PUTCH(138,-11)
10004 CALL SWT
      END
      SUBROUTINE ARGSC0
      INTEGER ARG(10)
      INTEGER FIRST0,LASTA0,BACKNO,I
      INTEGER GETARG,CTOI
      INTEGER PTR
      INTEGER ACCES0
      IF((GETARG(1,ARG,10).NE.-1))GOTO 10005
        FIRST0=1
        GOTO 10006
10005   I=1
        FIRST0=CTOI(ARG,I)
10006 IF((GETARG(2,ARG,10).NE.-1))GOTO 10007
        LASTA0=64
        GOTO 10008
10007   I=1
        LASTA0=CTOI(ARG,I)
10008 IF((GETARG(3,ARG,10).NE.-1))GOTO 10009
        BACKNO=1
        GOTO 10010
10009   I=1
        BACKNO=CTOI(ARG,I)
10010 I=FIRST0
      GOTO 10013
10011 I=I+(1)
10013 IF((I.GT.LASTA0))GOTO 10012
        PTR=ACCES0(BACKNO,I)
        IF((PTR.NE.-1))GOTO 10014
          GOTO 10012
10014   CALL LSPUTF(PTR,-11)
        CALL PUTCH(138,-11)
      GOTO 10011
10012 CALL SWT
      END
      SUBROUTINE ARGST0
      INTEGER I,COUNT,BACKNO,ND,ST
      INTEGER GETARG,CTOI
      INTEGER PTR
      INTEGER ACCES0
      INTEGER DELIM(128),ARG(10)
      INTEGER LSCMPK
      IF((GETARG(1,DELIM,128).NE.-1))GOTO 10015
        CALL ERROR('Usage: argsto <delim> [<count> [<start> [<levels>]]]
     *.')
10015 IF((GETARG(2,ARG,10).NE.-1))GOTO 10016
        COUNT=0
        GOTO 10017
10016   I=1
        COUNT=CTOI(ARG,I)
10017 IF((GETARG(3,ARG,10).NE.-1))GOTO 10018
        ST=1
        GOTO 10019
10018   I=1
        ST=CTOI(ARG,I)
10019 IF((GETARG(4,ARG,10).NE.-1))GOTO 10020
        BACKNO=1
        GOTO 10021
10020   I=1
        BACKNO=CTOI(ARG,I)
10021 ND=0
      PTR=ACCES0(BACKNO,ST)
10022 IF((PTR.EQ.-1))GOTO 10023
      IF((ND.GT.COUNT))GOTO 10023
        IF((LSCMPK(PTR,DELIM).NE.189))GOTO 10024
          ND=ND+(1)
          GOTO 10025
10024     IF((ND.NE.COUNT))GOTO 10026
            CALL LSPUTF(PTR,-11)
            CALL PUTCH(138,-11)
10026   CONTINUE
10025   ST=ST+(1)
        PTR=ACCES0(BACKNO,ST)
      GOTO 10022
10023 CALL SWT
      END
      SUBROUTINE CASEC0
      INTEGER CMD(102),ARG(102),VAL(102)
      INTEGER NESTI0
      INTEGER GETNET,EQUAL,GETARG
      INTEGER AAAAA0(5)
      INTEGER AAAAB0(5)
      INTEGER AAAAC0(5)
      INTEGER AAAAD0(4)
      DATA AAAAA0/229,243,225,227,0/
      DATA AAAAB0/227,225,243,229,0/
      DATA AAAAC0/247,232,229,238,0/
      DATA AAAAD0/239,245,244,0/
      IF((GETARG(1,VAL,102).NE.-1))GOTO 10027
        VAL(1)=0
10027 NESTI0=0
10028   IF((GETNET(CMD,ARG).NE.-1))GOTO 10030
          CALL ERROR('missing ''esac''.')
10029   GOTO 10030
10031     IF((NESTI0.NE.0))GOTO 10032
            GOTO 10033
10032       NESTI0=NESTI0-(1)
        GOTO 10034
10035     NESTI0=NESTI0+(1)
        GOTO 10034
10036     IF((NESTI0.NE.0))GOTO 10034
          IF((EQUAL(ARG,VAL).EQ.0))GOTO 10034
            GOTO 10033
10038     IF((NESTI0.NE.0))GOTO 10034
            GOTO 10033
10030   IF((EQUAL(CMD,AAAAA0).NE.0))GOTO 10031
        IF((EQUAL(CMD,AAAAB0).NE.0))GOTO 10035
        IF((EQUAL(CMD,AAAAC0).NE.0))GOTO 10036
        IF((EQUAL(CMD,AAAAD0).NE.0))GOTO 10038
10034 CONTINUE
      GOTO 10028
10033 CALL SWT
      END
      SUBROUTINE CDCMD
      INTEGER PNAME(102)
      INTEGER PWD
      INTEGER GETARG,FOLLOW,EQUAL
      INTEGER AAAAE0(7)
      INTEGER AAAAF0(3)
      INTEGER AAAAG0(13)
      DATA AAAAE0/189,232,239,237,229,189,0/
      DATA AAAAF0/173,240,0/
      DATA AAAAG0/226,225,228,160,240,225,244,232,238,225,237,229,0/
      PWD=0
      IF((GETARG(1,PNAME,102).NE.-1))GOTO 10040
        CALL SCOPY(AAAAE0,1,PNAME,1)
        GOTO 10041
10040   IF((EQUAL(AAAAF0,PNAME).EQ.0))GOTO 10042
          PWD=1
          CALL GETARG(2,PNAME,102)
10042 CONTINUE
10041 IF((PWD.NE.1))GOTO 10043
        IF((FOLLOW(PNAME,0).NE.-3))GOTO 10044
          CALL ERROR(AAAAG0)
          GOTO 10046
10044     CALL GCDIR$(PNAME)
          CALL PRINT(-11,'*s*n.',PNAME)
          CALL FOLLOW(0,0)
10045   GOTO 10046
10043   IF((FOLLOW(PNAME,1).NE.-3))GOTO 10047
          CALL ERROR('bad pathname.')
10047 CONTINUE
10046 CALL SWT
      END
      SUBROUTINE DATEC0
      INTEGER VALUE(102)
      INTEGER AAAAH0(5)
      DATA AAAAH0/170,243,170,238,0/
      CALL DATE(1,VALUE)
      CALL PRINT(-11,AAAAH0,VALUE)
      CALL SWT
      END
      SUBROUTINE DAYCMD
      INTEGER I,DAY,MONTH,YEAR
      INTEGER GETARG,PARSDT,WKDAY
      INTEGER ARG(10)
      INTEGER POS(9)
      INTEGER TEXT(40)
      INTEGER AAAAI0(37)
      INTEGER AAAAJ0(7)
      DATA TEXT/211,245,238,0,205,239,238,0,212,245,229,243,0,215,229,22
     *8,238,229,243,0,212,232,245,242,243,0,198,242,233,0,211,225,244,24
     *5,242,0,228,225,249,0/
      DATA POS/8,1,5,9,14,21,27,31,37/
      DATA AAAAI0/213,243,225,231,229,186,160,228,225,249,160,219,160,22
     *8,228,160,252,160,237,237,175,228,228,160,252,160,237,237,175,228,
     *228,175,249,249,160,221,0/
      DATA AAAAJ0/170,243,170,243,170,238,0/
      IF((GETARG(1,ARG,10).NE.-1))GOTO 10048
        CALL DATE(1,ARG)
10048 I=1
      IF((PARSDT(ARG,I,MONTH,DAY,YEAR).NE.-3))GOTO 10049
        CALL ERROR(AAAAI0)
        GOTO 10050
10049   CALL PRINT(-11,AAAAJ0,TEXT(POS(WKDAY(MONTH,DAY,YEAR)+1)),TEXT(PO
     *S(9)))
10050 CALL SWT
      END
      SUBROUTINE DBGCMD
      INTEGER I,LEN
      INTEGER GETARG,ENCODE
      INTEGER CMD(255),ARG(255)
      INTEGER AAAAK0(7)
      DATA AAAAK0/228,226,231,160,170,243,0/
      I=1
      GOTO 10053
10051 I=I+(1)
10053 IF((GETARG(I,ARG,2).EQ.-1))GOTO 10052
      IF((ARG(1).NE.173))GOTO 10052
      GOTO 10051
10052 IF((GETARG(I,ARG,255).EQ.-1))GOTO 10054
        CALL EXPAND(ARG,CMD,255)
        CALL MKTR$(CMD,ARG)
10054 CALL DELARG(0)
      LEN=ENCODE(CMD,255,AAAAK0,ARG)
      GOTO 10057
10055 I=I-(1)
10057 IF((I.LE.1))GOTO 10056
        IF((LEN.LT.255))GOTO 10058
          CALL ERROR('command too long.')
10058   CMD(LEN+1)=160
        LEN=LEN+(GETARG(0,CMD(LEN+2),255-LEN-1)+1)
        CALL DELARG(0)
      GOTO 10055
10056 CALL SYS$$(CMD,-3)
      CALL SWT
      END
      SUBROUTINE DECLA0
      INTEGER VAR(102),VAL(102),JUNK(3)
      INTEGER I
      INTEGER GETARG
      I=1
      GOTO 10061
10059 I=I+(1)
10061 IF((GETARG(I,VAR,102).EQ.-1))GOTO 10060
        IF((GETARG(I+1,JUNK,3).EQ.-1))GOTO 10062
        IF((JUNK(1).NE.189))GOTO 10062
        IF((JUNK(2).NE.0))GOTO 10062
        IF((GETARG(I+2,VAL,102).EQ.-1))GOTO 10062
          I=I+(2)
          GOTO 10063
10062     VAL(1)=0
10063   CALL SVMAKE(VAR,VAL)
      GOTO 10059
10060 CALL SWT
      END
      SUBROUTINE DECLB0
      COMMON /SVCOM/SVLLA0,SVTBL0(32,13),SVMEM0(4096),EOFSA0(32),ESAVE0(
     *32),ESCSA0(32),KSAVE0(32),NLSAV0(32),RTSAV0(32),KRESP0(33,32),PDES
     *T0(17,32),PFORM0(9,32)
      INTEGER SVLLA0,SVTBL0,SVMEM0,EOFSA0,ESAVE0,ESCSA0,KSAVE0,NLSAV0,RT
     *SAV0,KRESP0,PDEST0,PFORM0
      INTEGER I,LEVEL,DECLL0
      INTEGER CTOI,GETARG,SVFIND
      INTEGER NAME(128),COUNT(128)
      IF((GETARG(1,NAME,128).NE.-1))GOTO 10064
        CALL ERROR('Usage: declared <variable> [ <level offset> ].')
10064 IF((GETARG(2,COUNT,128).NE.-1))GOTO 10065
        LEVEL=0
        GOTO 10066
10065   I=1
        LEVEL=SVLLA0-CTOI(COUNT,I)
        IF((LEVEL.GT.0))GOTO 10067
          LEVEL=-3
10067 CONTINUE
10066 DECLL0=SVFIND(NAME,I)
      IF((DECLL0.EQ.LEVEL))GOTO 10069
      IF((LEVEL.NE.0))GOTO 10068
      IF((DECLL0.EQ.-1))GOTO 10068
      GOTO 10069
10069   CALL PUTCH(177,-11)
        GOTO 10071
10068   CALL PUTCH(176,-11)
10071 CALL PUTCH(138,-11)
      CALL SWT
      END
      SUBROUTINE DROPC0
      INTEGER I,CHARS
      INTEGER GCTOI,GETLIN,GETARG
      INTEGER ARG(102)
      INTEGER AAAAL0(34)
      INTEGER AAAAM0(5)
      INTEGER AAAAN0(5)
      DATA AAAAL0/213,243,225,231,229,186,160,228,242,239,240,160,188,23
     *8,227,232,225,242,243,190,160,219,160,188,243,244,242,233,238,231,
     *190,160,221,0/
      DATA AAAAM0/170,243,170,238,0/
      DATA AAAAN0/170,243,170,238,0/
      IF((GETARG(1,ARG,102).NE.-1))GOTO 10072
        CALL ERROR(AAAAL0)
10072 I=1
      CHARS=GCTOI(ARG,I,10)
      IF((GETARG(2,ARG,102).EQ.-1))GOTO 10073
        CALL SDROP(ARG,ARG,CHARS)
        CALL PRINT(-11,AAAAM0,ARG)
        GOTO 10074
10073   CONTINUE
10075     I=GETLIN(ARG,-10)
          IF((I.NE.-1))GOTO 10076
            GOTO 10077
10076     IF((ARG(I).NE.138))GOTO 10078
            ARG(I)=0
10078     CALL SDROP(ARG,ARG,CHARS)
          CALL PRINT(-11,AAAAN0,ARG)
        GOTO 10075
10077 CONTINUE
10074 CALL SWT
      END
      SUBROUTINE DUMPC0
      COMMON /SWT$CM/TERMB0(128),TERMC0,TERMD0,ECHAR0,KCHAR0,NLCHA0,EOFC
     *H0,ESCCH0,RTCHA0,ISPHA0,CPUTY0,ERRCO0,STDPO0(6),KILLR0(33),FDMEM0(
     *16,128),RESES0(846),FDBUF0(16384),PASSW0(7),BPLAB0(4),UTEMP0,FDLAS
     *0,PRTDE0(17),PRTFO0(9),UHASH0(37),UTEMQ0(4059),RESET0(985),CMDST0,
     *COMUN0,RTLAB0(4),FIRSU0,ARGCA0,ARGVA0(256),TERMA0(6),TERMT0(7),LWO
     *RD0,LSHOA0,LSTOP0,LSNAA0,LSREF0(16384),RESEU0(743),TSSTA0,TSGTA0,T
     *SATA0,TSEOS0,TSUNA0(32),TSPSA0(32),TSBFA0(32,32),TSPWA0(3,32),TSPA
     *T0(180),RESEV0(680),NEWSC0(85,51),RESEW0(785),CURSC0(85,51),RESEX0
     *(785),TCCLE0(10),TCCLF0(10),TCCLG0(10),TCCUR0(10),TCCUS0(10),TCCUT
     *0(10),TCCUU0(10),TCCUV0(10),TCABS0(10),TCVER0(10),TCHOR0(10),TCINS
     *0(10),TCDEL0(10),TCSHI0(10),TCSHJ0(10),TCCOO0,TCSHK0,TCCOP0,TCSEQ0
     *,TCSPE0,TCCLH0,TCLIN0,TCPOS0,TCWRA0,TCCLR0,TCCEO0,TCCEP0,TCABT0,TC
     *VES0,TCHOS0,TCHOM0,TCLEF0,TCUPL0,UNPRI0,COLCH0(51),COLCI0(51),ROWC
     *H0,ROWCI0,LASTC0(51),MAXRO0,MAXCO0,CURRO0,CURCO0,MSGRO0,MSGOW0(85)
     *,PADRO0,PADCO0,PADLE0,DISPL0,FNTAB0(128,20),LASTF0,TABSA0(85),INPU
     *T0(51),INPUU0(51),INBUF0(85),LASTD0,INSER0,INVER0,DUPLE0,INPUV0,PB
     *BUF0(400),PBPTR0,FNUSE0(20),DEFBU0(1000),LASTE0,NESTJ0,RESEY0(1)
      INTEGER TERMB0,TERMC0,TERMD0,ECHAR0,KCHAR0,NLCHA0,EOFCH0,ESCCH0,RT
     *CHA0,ISPHA0,CPUTY0,ERRCO0,STDPO0,FDMEM0,RESES0,FDBUF0,PASSW0,BPLAB
     *0,UTEMP0,UHASH0,UTEMQ0,RESET0,CMDST0,COMUN0,RTLAB0,FIRSU0,ARGCA0,A
     *RGVA0,TERMA0,TERMT0,LSHOA0,LSTOP0,LSNAA0,LSREF0,RESEU0,FDLAS0,KILL
     *R0,PRTDE0,PRTFO0,LWORD0,TSSTA0,TSGTA0,TSATA0,TSEOS0,TSUNA0,TSPSA0,
     *TSBFA0,TSPWA0,TSPAT0,RESEV0,NEWSC0,RESEW0,CURSC0,RESEX0,TCCLE0,TCC
     *LF0,TCCLG0,TCCUR0,TCCUS0,TCCUT0,TCCUU0,TCCUV0,TCABS0,TCVER0,TCHOR0
     *,TCINS0,TCDEL0,TCCLH0,TCLIN0,TCPOS0,TCSHI0,TCSHJ0,TCCOO0,TCSHK0,TC
     *COP0,TCSEQ0,TCDEM0,TCWRA0,TCCLR0,TCSPE0,TCCEO0,TCCEP0,TCABT0,TCVES
     *0,TCHOS0,UNPRI0,COLCH0,COLCI0,ROWCH0,ROWCI0,LASTC0,MAXRO0,MAXCO0,C
     *URRO0,CURCO0,MSGRO0,MSGOW0,PADRO0,PADCO0,PADLE0,DISPL0,FNTAB0,LAST
     *F0,TABSA0,INPUT0,INPUU0,INBUF0,LASTD0,INSER0,INVER0,DUPLE0,INPUV0,
     *PBBUF0,PBPTR0,FNUSE0,DEFBU0,LASTE0,NESTJ0,TCHOM0,TCLEF0,TCUPL0,RES
     *EY0
      INTEGER FDESC0(16),FDDEV0(1),FDUNI0(1),FDBUG0(1),FDBUH0(1),FDBUI0(
     *1),FDCOU0(1),FDBCO0(1),FDFLA0(1),FDVCS0(1),FDVCT0(1),FDOPS0(1),FDO
     *PT0(1),FDOPU0(1)
      INTEGER AP,I,L
      INTEGER GETARG,CTOI,STRLSR
      INTEGER ARG(128)
      INTEGER APOS(13)
      INTEGER ATXT(120)
      INTEGER AAAAO0
      INTEGER AAAAP0(27)
      EQUIVALENCE (FDMEM0,FDESC0),(FDDEV0,FDESC0(1)),(FDUNI0,FDESC0(2)),
     *(FDBUG0,FDESC0(3)),(FDBUH0,FDESC0(4)),(FDBUI0,FDESC0(5)),(FDCOU0,F
     *DESC0(6)),(FDBCO0,FDESC0(7)),(FDFLA0,FDESC0(8)),(FDVCS0,FDESC0(9))
     *,(FDVCT0,FDESC0(10)),(FDOPS0,FDESC0(11)),(FDOPT0,FDESC0(12)),(FDOP
     *U0,FDESC0(13))
      DATA ATXT/1,236,243,0,1,236,233,238,235,229,228,223,243,244,242,23
     *3,238,231,0,2,243,246,0,2,243,232,229,236,236,223,246,225,242,233,
     *225,226,236,229,0,2,243,232,229,236,236,223,246,225,242,233,225,22
     *6,236,229,243,0,3,230,228,0,3,230,233,236,229,223,228,229,243,227,
     *0,3,230,233,236,229,223,228,229,243,227,242,233,240,244,239,242,0,
     *4,227,237,0,4,227,239,237,237,239,238,0,4,243,247,244,223,227,239,
     *237,237,239,238,0,4,243,247,244,164,227,237,0/
      DATA APOS/12,1,5,20,24,40,57,61,72,89,93,101,113/
      DATA AAAAP0/170,243,186,160,226,225,228,160,230,233,236,229,160,22
     *8,229,243,227,160,238,245,237,226,229,242,170,238,0/
      AP=1
      GOTO 10081
10079 AP=AP+(1)
10081 IF((GETARG(AP,ARG,128).EQ.-1))GOTO 10080
        L=STRLSR(APOS,ATXT,1,ARG)
        IF((L.NE.-1))GOTO 10082
          CALL REMARK('Usage:  dump { ls | linked_string.')
          CALL REMARK('             | sv | shell_variables.')
          CALL REMARK('             | fd [ <num> ] | file_desc [ <num> ]
     *.')
          CALL ERROR('             | cm | swt_common }.')
10082   AAAAO0=ATXT(APOS(L))
        GOTO 10083
10084     CALL LSDUMP(-11)
        GOTO 10079
10086     CALL SVDUMP(-11)
        GOTO 10079
10087     IF((GETARG(AP+1,ARG,128).EQ.-1))GOTO 10088
          IF((176.GT.ARG(1)))GOTO 10088
          IF((ARG(1).GT.185))GOTO 10088
            I=1
            L=CTOI(ARG,I)
            IF((L.LT.1))GOTO 10089
            IF((L.GT.128))GOTO 10089
            IF((ARG(I).NE.0))GOTO 10089
              CALL DMPFD$(L,-11)
              GOTO 10090
10089         CALL PRINT(-15,AAAAP0,ARG)
10090       AP=AP+(1)
            GOTO 10079
10088       I=1
            GOTO 10094
10092       I=I+(1)
10094       IF((I.GT.128))GOTO 10093
              IF((FDFLA0(I*16-16+1).EQ.0))GOTO 10092
                CALL DMPFD$(I,-11)
10095       GOTO 10092
10093     CONTINUE
10091   GOTO 10079
10096     CALL DMPCM$(-11)
        GOTO 10079
10083   GOTO(10084,10086,10087,10096),AAAAO0
10085 GOTO 10079
10080 CALL SWT
      END
      SUBROUTINE ECHOC0
      INTEGER ARG(128)
      INTEGER I,J
      INTEGER GETARG
      INTEGER ESC
      I=1
      GOTO 10099
10097 I=I+(1)
10099 IF((GETARG(I,ARG,128).EQ.-1))GOTO 10098
        IF((I.LE.1))GOTO 10100
          CALL PUTCH(160,-11)
10100   J=1
        GOTO 10103
10101   J=J+(1)
10103   IF((ARG(J).EQ.0))GOTO 10097
          CALL PUTCH(ESC(ARG,J),-11)
        GOTO 10101
10098 IF((I.LE.1))GOTO 10104
        CALL PUTCH(138,-11)
10104 CALL SWT
      END
      INTEGER FUNCTION ESC(ARRAY,I)
      INTEGER ARRAY(1)
      INTEGER I
      IF((ARRAY(I).EQ.192))GOTO 10105
        ESC=ARRAY(I)
        GOTO 10106
10105   IF((ARRAY(I+1).NE.0))GOTO 10107
          ESC=192
          GOTO 10108
10107     I=I+1
          IF((ARRAY(I).NE.238))GOTO 10109
            ESC=138
            GOTO 10110
10109       IF((ARRAY(I).NE.244))GOTO 10111
              ESC=137
              GOTO 10112
10111         ESC=ARRAY(I)
10112     CONTINUE
10110   CONTINUE
10108 CONTINUE
10106 RETURN
      END
      SUBROUTINE ELSEC0
      INTEGER NESTI0
      INTEGER GETNET,EQUAL
      INTEGER CMD(102),ARG(102)
      INTEGER AAAAQ0(3)
      INTEGER AAAAR0(3)
      DATA AAAAQ0/230,233,0/
      DATA AAAAR0/233,230,0/
      NESTI0=0
10113   IF((GETNET(CMD,ARG).NE.-1))GOTO 10115
          CALL ERROR('missing ''fi''.')
10114   GOTO 10115
10116     IF((NESTI0.NE.0))GOTO 10117
            GOTO 10118
10117       NESTI0=NESTI0-(1)
        GOTO 10119
10120     NESTI0=NESTI0+(1)
        GOTO 10119
10115   IF((EQUAL(CMD,AAAAQ0).NE.0))GOTO 10116
        IF((EQUAL(CMD,AAAAR0).NE.0))GOTO 10120
10119 CONTINUE
      GOTO 10113
10118 CALL SWT
      END
      SUBROUTINE EVALC0
      INTEGER * 4 EVALU0,INTVA0
      INTEGER ESTAT0,EBUFA0(102),EPAAA0,TOKEN0,GLOBA0
      INTEGER GETLIN
      INTEGER IDAAA0(102)
      INTEGER SYNTA0(27)
      INTEGER AAAAS0
      INTEGER AAAAT0
      INTEGER AAAAU0
      INTEGER AAAAV0
      INTEGER AAAAW0(16)
      INTEGER AAAAX0
      INTEGER AAAAY0(16)
      INTEGER AAAAZ0
      INTEGER AAABA0(16)
      INTEGER AAABB0
      INTEGER AAABC0(16)
      INTEGER AAABD0
      INTEGER AAABE0(16)
      INTEGER AAABF0
      INTEGER AAABG0(16)
      INTEGER AAABH0
      INTEGER AAABI0(16)
      INTEGER AAABJ0
      INTEGER AAABK0(16)
      INTEGER AAABL0
      INTEGER AAABM0(16)
      INTEGER AAABN0
      INTEGER AAABO0,AAABP0,AAABQ0
      INTEGER GETARG
      INTEGER AAABR0
      INTEGER * 4 GCTOL
      INTEGER AAABS0
      INTEGER AAABT0
      INTEGER AAABU0
      INTEGER AAABV0
      INTEGER AAABW0
      INTEGER AAABX0
      INTEGER AAABY0
      INTEGER AAABZ0
      INTEGER AAACA0(32)
      INTEGER AAACB0
      INTEGER SVGET
      INTEGER * 4 GCTOL
      INTEGER AAACE0,AAACD0(16)
      INTEGER * 4 AAACC0(16)
      INTEGER AAACF0
      INTEGER AAACH0
      INTEGER * 4 AAACG0(16)
      INTEGER AAACK0,AAACJ0(16)
      INTEGER * 4 AAACI0(16)
      INTEGER AAACL0
      INTEGER AAACM0
      INTEGER AAACP0,AAACO0(16)
      INTEGER * 4 AAACN0(16)
      INTEGER AAACQ0
      INTEGER AAACR0
      INTEGER AAACU0,AAACT0(16)
      INTEGER * 4 AAACS0(16)
      INTEGER AAACV0
      INTEGER AAACW0
      INTEGER AAACY0
      INTEGER * 4 AAACX0(16)
      DATA SYNTA0/243,249,238,244,225,248,160,229,242,242,239,242,160,23
     *3,238,160,229,248,240,242,229,243,243,233,239,238,0/
      AAAAX0=1
      AAAAZ0=1
      AAABB0=1
      AAABD0=1
      AAABF0=1
      AAABH0=1
      AAABJ0=1
      AAABL0=1
      AAABN0=1
      AAAAS0=1
      GOTO 10121
10134 IF((EBUFA0(1).EQ.0))GOTO 10135
        ESTAT0=-2
        AAAAT0=1
        GOTO 10122
10136   GLOBA0=1
        AAAAW0(AAAAX0)=1
        GOTO 10125
10137   IF((ESTAT0.NE.-2))GOTO 10138
          AAAAV0=1
          GOTO 10124
10139   CONTINUE
10138   IF((ESTAT0.NE.-2))GOTO 10141
          CALL PRINT(-11,'*l*n.',EVALU0)
10140   GOTO 10141
10135   ESTAT0=-2
        GOTO 10144
10142   ESTAT0=-2
10144   IF((GETLIN(EBUFA0,-10).EQ.-1))GOTO 10143
          EPAAA0=1
          AAAAT0=2
          GOTO 10122
10145     IF((TOKEN0.NE.138))GOTO 10146
            GOTO 10142
10146     GLOBA0=1
          AAAAW0(AAAAX0)=2
          GOTO 10125
10147     AAAAV0=2
          GOTO 10124
10148     IF((ESTAT0.NE.-2))GOTO 10142
            CALL PRINT(-11,'*l*n.',EVALU0)
10149   GOTO 10142
10143 CONTINUE
10141 IF((ESTAT0.EQ.-2))GOTO 10150
        CALL SETERR(1000)
10150 CALL SWT
10121 AAABP0=0
      AAABO0=1
      GOTO 10153
10151 AAABP0=AAABP0+(AAABQ0)
      AAABO0=AAABO0+(1)
10153 IF((AAABP0.GE.102-1))GOTO 10152
        IF((AAABP0.LE.0))GOTO 10154
          AAABP0=AAABP0+(1)
          EBUFA0(AAABP0)=160
10154   AAABQ0=GETARG(AAABO0,EBUFA0(AAABP0+1),102-AAABP0)
        IF((AAABQ0.NE.-1))GOTO 10151
          GOTO 10152
10152 EBUFA0(AAABP0+1)=0
      EPAAA0=1
      GOTO 10134
10122 CONTINUE
10157 IF((EBUFA0(EPAAA0).NE.160))GOTO 10158
        EPAAA0=EPAAA0+(1)
      GOTO 10157
10158 AAABS0=EBUFA0(EPAAA0)
      GOTO 10159
10160   TOKEN0=-108
        AAABR0=1
10161     IDAAA0(AAABR0)=EBUFA0(EPAAA0)
          EPAAA0=EPAAA0+(1)
          AAABR0=AAABR0+(1)
        IF((193.GT.EBUFA0(EPAAA0)))GOTO 10162
        IF((EBUFA0(EPAAA0).GT.218))GOTO 10162
        GOTO 10161
10162   IF((225.GT.EBUFA0(EPAAA0)))GOTO 10163
        IF((EBUFA0(EPAAA0).GT.250))GOTO 10163
        GOTO 10161
10163   IF((176.GT.EBUFA0(EPAAA0)))GOTO 10164
        IF((EBUFA0(EPAAA0).GT.185))GOTO 10164
        GOTO 10161
10164   IF((EBUFA0(EPAAA0).EQ.223))GOTO 10161
        IF((EBUFA0(EPAAA0).EQ.164))GOTO 10161
        IDAAA0(AAABR0)=0
      GOTO 10194
10166   TOKEN0=-107
        INTVA0=GCTOL(EBUFA0,EPAAA0,10)
      GOTO 10194
10167   EPAAA0=EPAAA0+(1)
        AAABT0=EBUFA0(EPAAA0)
        GOTO 10168
10169     TOKEN0=-103
        GOTO 10170
10171     TOKEN0=-105
        GOTO 10170
10172     TOKEN0=-102
        GOTO 10170
10170     EPAAA0=EPAAA0+(1)
        GOTO 10194
10168   AAABU0=AAABT0-187
        GOTO(10171,10169,10172),AAABU0
          TOKEN0=188
10173 GOTO 10194
10174   EPAAA0=EPAAA0+(1)
        AAABV0=EBUFA0(EPAAA0)
        GOTO 10175
10176     TOKEN0=-104
        GOTO 10177
10178     TOKEN0=-106
        GOTO 10177
10177     EPAAA0=EPAAA0+(1)
        GOTO 10194
10175   AAABW0=AAABV0-188
        GOTO(10176,10178),AAABW0
          TOKEN0=190
10179 GOTO 10194
10180   EPAAA0=EPAAA0+(1)
        AAABX0=EBUFA0(EPAAA0)
        GOTO 10181
10182     TOKEN0=-102
        GOTO 10183
10184     TOKEN0=-104
        GOTO 10183
10185     TOKEN0=-103
        GOTO 10183
10183     EPAAA0=EPAAA0+(1)
        GOTO 10194
10181   AAABY0=AAABX0-187
        GOTO(10184,10182,10185),AAABY0
          TOKEN0=254
10186 GOTO 10194
10187   EPAAA0=EPAAA0+(1)
        IF((EBUFA0(EPAAA0).NE.189))GOTO 10188
          EPAAA0=EPAAA0+(1)
10188   TOKEN0=189
      GOTO 10194
10189   EPAAA0=EPAAA0+(1)
        IF((EBUFA0(EPAAA0).NE.170))GOTO 10190
          EPAAA0=EPAAA0+(1)
          TOKEN0=-101
          GOTO 10194
10190     TOKEN0=170
10191 GOTO 10194
10192   TOKEN0=138
      GOTO 10194
10159 IF(AAABS0.EQ.0)GOTO 10192
      IF(AAABS0.EQ.138)GOTO 10192
      AAABZ0=AAABS0-160
      GOTO(10180,10193,10193,10160,10193,10193,10193,10193,10193,10189, 
     *    10193,10193,10193,10193,10193,10166,10166,10166,10166,10166,  
     *   10166,10166,10166,10166,10166,10193,10193,10167,10187,10174,   
     *  10193,10193,10160,10160,10160,10160,10160,10160,10160,10160,    
     * 10160,10160,10160,10160,10160,10160,10160,10160,10160,10160,10160
     *,10160,10160,10160,10160,10160,10160,10160,10193,10193,10193,10193
     *,10160,10193,10160,10160,10160,10160,10160,10160,10160,10160,10160
     *,10160,10160,10160,10160,10160,10160,10160,10160,10160,10160,10160
     *,10160,10160,10160,10160,10160,10160,10193,10193,10193,10180),AAAB
     *Z0
10193   TOKEN0=EBUFA0(EPAAA0)
        EPAAA0=EPAAA0+(1)
10165 GOTO 10194
10123 IF((SVGET(IDAAA0,AAACA0,32).NE.-1))GOTO 10195
        INTVA0=0
        CALL PRINT(-15,'*s: undefined*n.',IDAAA0)
        ESTAT0=-3
        GOTO 10296
10195   AAACB0=1
        INTVA0=GCTOL(AAACA0,AAACB0,10)
        IF((AAACA0(AAACB0).EQ.0))GOTO 10197
          INTVA0=0
          CALL PRINT(-15,'*s: non-numeric (*s)*n.',IDAAA0,AAACA0)
          ESTAT0=-3
10197 CONTINUE
10196 GOTO 10296
10124 IF((TOKEN0.EQ.138))GOTO 10200
        ESTAT0=-3
        CALL PRINT(-15,'*,#s*n.',EPAAA0-1,EBUFA0)
        CALL REMARK(SYNTA0)
10199 GOTO 10200
10125 IF(AAAAX0.GE.16)CALL ERROR(23HCONTROL STACK OVERFLOW.)
      AAAAX0=AAAAX0+1
      IF((ESTAT0.EQ.-3))GOTO 10213
        IF((GLOBA0.EQ.0))GOTO 10202
          AAACE0=0
10202   AAACE0=AAACE0+(1)
        AAAAY0(AAAAZ0)=1
        GOTO 10126
10203   AAACC0(AAACE0)=EVALU0
10204   IF((TOKEN0.EQ.252))GOTO 10206
        IF((TOKEN0.EQ.222))GOTO 10206
        GOTO 10205
10206     AAACD0(AAACE0)=TOKEN0
          AAAAT0=3
          GOTO 10122
10207     AAAAY0(AAAAZ0)=2
          GOTO 10126
10208     AAACF0=AAACD0(AAACE0)
          GOTO 10209
10210       AAACC0(AAACE0)=OR(AAACC0(AAACE0),EVALU0)
          GOTO 10204
10212       AAACC0(AAACE0)=XOR(AAACC0(AAACE0),EVALU0)
          GOTO 10204
10209     IF(AAACF0.EQ.222)GOTO 10212
          IF(AAACF0.EQ.252)GOTO 10210
            CALL REMARK('in expression: can''t happen.')
            ESTAT0=-3
            GOTO 10205
10205   EVALU0=AAACC0(AAACE0)
        AAACE0=AAACE0-(1)
10201 GOTO 10213
10126 IF(AAAAZ0.GE.16)CALL ERROR(23HCONTROL STACK OVERFLOW.)
      AAAAZ0=AAAAZ0+1
      IF((ESTAT0.EQ.-3))GOTO 10221
        IF((GLOBA0.EQ.0))GOTO 10215
          AAACH0=0
10215   AAACH0=AAACH0+(1)
        AAABA0(AAABB0)=1
        GOTO 10127
10216   AAACG0(AAACH0)=EVALU0
10217   IF((TOKEN0.NE.166))GOTO 10218
          AAAAT0=4
          GOTO 10122
10219     AAABA0(AAABB0)=2
          GOTO 10127
10220     AAACG0(AAACH0)=AND(AAACG0(AAACH0),EVALU0)
        GOTO 10217
10218   EVALU0=AAACG0(AAACH0)
        AAACH0=AAACH0-(1)
10214 GOTO 10221
10127 IF(AAABB0.GE.16)CALL ERROR(23HCONTROL STACK OVERFLOW.)
      AAABB0=AAABB0+1
      IF((ESTAT0.EQ.-3))GOTO 10228
        IF((TOKEN0.NE.254))GOTO 10223
          AAAAT0=5
          GOTO 10122
10224     AAABC0(AAABD0)=1
          GOTO 10128
10225     EVALU0=NOT(EVALU0)
          GOTO 10226
10223     AAABC0(AAABD0)=2
          GOTO 10128
10227   CONTINUE
10226 CONTINUE
10222 GOTO 10228
10128 IF(AAABD0.GE.16)CALL ERROR(23HCONTROL STACK OVERFLOW.)
      AAABD0=AAABD0+1
      IF((ESTAT0.EQ.-3))GOTO 10245
        IF((GLOBA0.EQ.0))GOTO 10230
          AAACK0=0
10230   AAACK0=AAACK0+(1)
        AAABE0(AAABF0)=1
        GOTO 10129
10231   AAACI0(AAACK0)=EVALU0
10232   IF((TOKEN0.EQ.188))GOTO 10234
        IF((TOKEN0.EQ.-103))GOTO 10234
        IF((TOKEN0.EQ.189))GOTO 10234
        IF((TOKEN0.EQ.-102))GOTO 10234
        IF((TOKEN0.EQ.-104))GOTO 10234
        IF((TOKEN0.EQ.190))GOTO 10234
        GOTO 10233
10234     AAACJ0(AAACK0)=TOKEN0
          AAAAT0=6
          GOTO 10122
10235     AAABE0(AAABF0)=2
          GOTO 10129
10236     AAACL0=AAACJ0(AAACK0)
          GOTO 10237
10238       AAACI0(AAACK0)=RT(AAACI0(AAACK0).LT.EVALU0,1)
          GOTO 10232
10240       AAACI0(AAACK0)=RT(AAACI0(AAACK0).LE.EVALU0,1)
          GOTO 10232
10241       AAACI0(AAACK0)=RT(AAACI0(AAACK0).EQ.EVALU0,1)
          GOTO 10232
10242       AAACI0(AAACK0)=RT(AAACI0(AAACK0).NE.EVALU0,1)
          GOTO 10232
10243       AAACI0(AAACK0)=RT(AAACI0(AAACK0).GE.EVALU0,1)
          GOTO 10232
10244       AAACI0(AAACK0)=RT(AAACI0(AAACK0).GT.EVALU0,1)
          GOTO 10232
10237     AAACM0=AAACL0+105
          GOTO(10243,10240,10242),AAACM0
          AAACM0=AAACL0-187
          GOTO(10238,10241,10244),AAACM0
            CALL REMARK('in expr2: can''t happen.')
            ESTAT0=-3
            GOTO 10233
10233   EVALU0=AAACI0(AAACK0)
        AAACK0=AAACK0-(1)
10229 GOTO 10245
10129 IF(AAABF0.GE.16)CALL ERROR(23HCONTROL STACK OVERFLOW.)
      AAABF0=AAABF0+1
      IF((ESTAT0.EQ.-3))GOTO 10259
        IF((GLOBA0.EQ.0))GOTO 10247
          AAACP0=0
10247   AAACP0=AAACP0+(1)
        AAABG0(AAABH0)=1
        GOTO 10130
10248   AAACN0(AAACP0)=EVALU0
10249   IF((TOKEN0.EQ.171))GOTO 10251
        IF((TOKEN0.EQ.173))GOTO 10251
        GOTO 10250
10251     AAACO0(AAACP0)=TOKEN0
          AAAAT0=7
          GOTO 10122
10252     AAABG0(AAABH0)=2
          GOTO 10130
10253     AAACQ0=AAACO0(AAACP0)
          GOTO 10254
10255       AAACN0(AAACP0)=AAACN0(AAACP0)+(EVALU0)
          GOTO 10249
10257       AAACN0(AAACP0)=AAACN0(AAACP0)-(EVALU0)
          GOTO 10249
10254     AAACR0=AAACQ0-170
          GOTO(10255,10258,10257),AAACR0
10258       CALL REMARK('in expr4: can''t happen.')
            ESTAT0=-3
            GOTO 10250
10250   EVALU0=AAACN0(AAACP0)
        AAACP0=AAACP0-(1)
10246 GOTO 10259
10130 IF(AAABH0.GE.16)CALL ERROR(23HCONTROL STACK OVERFLOW.)
      AAABH0=AAABH0+1
      IF((ESTAT0.EQ.-3))GOTO 10276
        IF((GLOBA0.EQ.0))GOTO 10261
          AAACU0=0
10261   AAACU0=AAACU0+(1)
        AAABI0(AAABJ0)=1
        GOTO 10131
10262   AAACS0(AAACU0)=EVALU0
10263   IF((TOKEN0.EQ.170))GOTO 10265
        IF((TOKEN0.EQ.175))GOTO 10265
        IF((TOKEN0.EQ.165))GOTO 10265
        IF((TOKEN0.EQ.-105))GOTO 10265
        IF((TOKEN0.EQ.-106))GOTO 10265
        GOTO 10264
10265     AAACT0(AAACU0)=TOKEN0
          AAAAT0=8
          GOTO 10122
10266     AAABI0(AAABJ0)=2
          GOTO 10131
10267     AAACV0=AAACT0(AAACU0)
          GOTO 10268
10269       AAACS0(AAACU0)=AAACS0(AAACU0)*(EVALU0)
          GOTO 10263
10271       AAACS0(AAACU0)=AAACS0(AAACU0)/(EVALU0)
          GOTO 10263
10272       AAACS0(AAACU0)=MOD(AAACS0(AAACU0),EVALU0)
          GOTO 10263
10273       AAACS0(AAACU0)=LS(AAACS0(AAACU0),EVALU0)
          GOTO 10263
10274       AAACS0(AAACU0)=RS(AAACS0(AAACU0),EVALU0)
          GOTO 10263
10268     AAACW0=AAACV0+107
          GOTO(10274,10273),AAACW0
          AAACW0=AAACV0-164
          GOTO(10272,10275,10275,10275,10275,10269,10275,10275,10275,   
     *  10275,10271),AAACW0
10275       CALL REMARK('in term: can''t happen.')
            ESTAT0=-3
            GOTO 10264
10264   EVALU0=AAACS0(AAACU0)
        AAACU0=AAACU0-(1)
10260 GOTO 10276
10131 IF(AAABJ0.GE.16)CALL ERROR(23HCONTROL STACK OVERFLOW.)
      AAABJ0=AAABJ0+1
      IF((ESTAT0.EQ.-3))GOTO 10284
        IF((GLOBA0.EQ.0))GOTO 10278
          AAACY0=0
10278   AAACY0=AAACY0+(1)
        AAABK0(AAABL0)=1
        GOTO 10132
10279   AAACX0(AAACY0)=EVALU0
10280   IF((TOKEN0.NE.-101))GOTO 10281
          AAAAT0=9
          GOTO 10122
10282     AAABK0(AAABL0)=2
          GOTO 10132
10283     AAACX0(AAACY0)=AAACX0(AAACY0)**EVALU0
        GOTO 10280
10281   EVALU0=AAACX0(AAACY0)
        AAACY0=AAACY0-(1)
10277 GOTO 10284
10132 IF(AAABL0.GE.16)CALL ERROR(23HCONTROL STACK OVERFLOW.)
      AAABL0=AAABL0+1
      IF((ESTAT0.EQ.-3))GOTO 10291
        IF((TOKEN0.NE.173))GOTO 10286
          AAAAT0=10
          GOTO 10122
10287     AAABM0(AAABN0)=1
          GOTO 10133
10288     EVALU0=-EVALU0
          GOTO 10289
10286     AAABM0(AAABN0)=2
          GOTO 10133
10290   CONTINUE
10289 CONTINUE
10285 GOTO 10291
10133 IF(AAABN0.GE.16)CALL ERROR(23HCONTROL STACK OVERFLOW.)
      AAABN0=AAABN0+1
      IF((ESTAT0.EQ.-3))GOTO 10306
        IF((TOKEN0.EQ.-108))GOTO 10294
        IF((TOKEN0.EQ.-107))GOTO 10294
        GOTO 10293
10294     IF((TOKEN0.NE.-108))GOTO 10295
            AAAAU0=1
            GOTO 10123
10296     CONTINUE
10295     EVALU0=INTVA0
          AAAAT0=11
          GOTO 10122
10293     IF((TOKEN0.NE.168))GOTO 10299
            AAAAT0=12
            GOTO 10122
10300       GLOBA0=0
            AAAAW0(AAAAX0)=3
            GOTO 10125
10301       IF((TOKEN0.NE.169))GOTO 10302
              AAAAT0=13
              GOTO 10122
10302         CALL REMARK('missing right parenthesis.')
              ESTAT0=-3
10304       GOTO 10305
10299       CALL PRINT(-15,'*,#s*n.',EPAAA0-1,EBUFA0)
            CALL REMARK(SYNTA0)
            ESTAT0=-3
10305   CONTINUE
10298 CONTINUE
10292 GOTO 10306
10200 GOTO(10139,10148),AAAAV0
      GOTO 10200
10276 AAABH0=AAABH0-1
      IF (AAABH0.LE.0)CALL ERROR(24HCONTROL STACK UNDERFLOW.)
      GOTO(10248,10253),AAABG0(AAABH0)
      GOTO 10276
10284 AAABJ0=AAABJ0-1
      IF (AAABJ0.LE.0)CALL ERROR(24HCONTROL STACK UNDERFLOW.)
      GOTO(10262,10267),AAABI0(AAABJ0)
      GOTO 10284
10221 AAAAZ0=AAAAZ0-1
      IF (AAAAZ0.LE.0)CALL ERROR(24HCONTROL STACK UNDERFLOW.)
      GOTO(10203,10208),AAAAY0(AAAAZ0)
      GOTO 10221
10213 AAAAX0=AAAAX0-1
      IF (AAAAX0.LE.0)CALL ERROR(24HCONTROL STACK UNDERFLOW.)
      GOTO(10137,10147,10301),AAAAW0(AAAAX0)
      GOTO 10213
10228 AAABB0=AAABB0-1
      IF (AAABB0.LE.0)CALL ERROR(24HCONTROL STACK UNDERFLOW.)
      GOTO(10216,10220),AAABA0(AAABB0)
      GOTO 10228
10245 AAABD0=AAABD0-1
      IF (AAABD0.LE.0)CALL ERROR(24HCONTROL STACK UNDERFLOW.)
      GOTO(10225,10227),AAABC0(AAABD0)
      GOTO 10245
10259 AAABF0=AAABF0-1
      IF (AAABF0.LE.0)CALL ERROR(24HCONTROL STACK UNDERFLOW.)
      GOTO(10231,10236),AAABE0(AAABF0)
      GOTO 10259
10291 AAABL0=AAABL0-1
      IF (AAABL0.LE.0)CALL ERROR(24HCONTROL STACK UNDERFLOW.)
      GOTO(10279,10283),AAABK0(AAABL0)
      GOTO 10291
10306 AAABN0=AAABN0-1
      IF (AAABN0.LE.0)CALL ERROR(24HCONTROL STACK UNDERFLOW.)
      GOTO(10288,10290),AAABM0(AAABN0)
      GOTO 10306
10194 GOTO(10136,10145,10207,10219,10224,10235,10252,10266,10282,10287, 
     *    10298,10300,10305),AAAAT0
      GOTO 10194
      END
      SUBROUTINE EXITD0
      INTEGER CIFIL0,CIFDA0(10),CIERR0,CITRA0,CICNO0(10)
      INTEGER CIBUF0(10),CIQUO0,CISEA0,CIQUP0,CIERS0,CIPRO0,CIHEL0,CIDEF
     *0
      INTEGER CIREC0
      INTEGER * 4 CIMDA0,CIMSI0,CICHE0
      COMMON /CICOM/CIQUO0,CISEA0,CIQUP0,CIPRO0,CIHEL0,CIERS0,CIDEF0,CIF
     *IL0,CITRA0,CIREC0,CIERR0,CIFDA0,CICNO0,CIBUF0,CIMDA0,CIMSI0,CICHE0
      INTEGER I,NLEVE0
      INTEGER CTOI,GETARG
      INTEGER ARG(5)
      IF((GETARG(1,ARG,5).NE.-1))GOTO 10307
        NLEVE0=1
        GOTO 10308
10307   I=1
        NLEVE0=CTOI(ARG,I)
10308 I=CIFIL0
      GOTO 10311
10309 I=I-(1)
      NLEVE0=NLEVE0-(1)
10311 IF((I.LE.0))GOTO 10310
      IF((NLEVE0.LE.0))GOTO 10310
        CALL WIND(CIFDA0(I))
        CALL LSFREE(CIBUF0(I),10000)
      GOTO 10309
10310 CALL SWT
      END
      SUBROUTINE FORGE0
      INTEGER VAR(102)
      INTEGER I
      INTEGER GETARG
      I=1
      GOTO 10314
10312 I=I+(1)
10314 IF((GETARG(I,VAR,102).EQ.-1))GOTO 10313
        CALL SVDEL(VAR)
      GOTO 10312
10313 CALL SWT
      END
      SUBROUTINE GOTOC0
      INTEGER CIFIL0,CIFDA0(10),CIERR0,CITRA0,CICNO0(10)
      INTEGER CIBUF0(10),CIQUO0,CISEA0,CIQUP0,CIERS0,CIPRO0,CIHEL0,CIDEF
     *0
      INTEGER CIREC0
      INTEGER * 4 CIMDA0,CIMSI0,CICHE0
      COMMON /CICOM/CIQUO0,CISEA0,CIQUP0,CIPRO0,CIHEL0,CIERS0,CIDEF0,CIF
     *IL0,CITRA0,CIREC0,CIERR0,CIFDA0,CICNO0,CIBUF0,CIMDA0,CIMSI0,CICHE0
      INTEGER NET
      INTEGER GETARG,GETNF0,EQUAL
      INTEGER LABEL(102),NETLA0(102)
      IF((GETARG(1,LABEL,102).NE.-1))GOTO 10315
        CALL ERROR('Usage: goto <label>.')
10315 IF((CIFDA0(CIFIL0).EQ.1))GOTO 10316
        CALL LSFREE(CIBUF0(CIFIL0),10000)
        CIBUF0(CIFIL0)=0
        CALL REWIND(CIFDA0(CIFIL0))
10316 CONTINUE
10317 IF((GETNF0(NETLA0,NET).EQ.-1))GOTO 10318
        IF((NETLA0(1).EQ.0))GOTO 10319
        IF((EQUAL(LABEL,NETLA0(2)).EQ.0))GOTO 10319
          CALL PUTBA0(NET)
          CALL SWT
10319     CALL LSFREE(NET,10000)
      GOTO 10317
10318 CALL ERROR('goto could not find target label.')
      END
      INTEGER FUNCTION GETNF0(NETLA0,NET)
      INTEGER NETLA0(1)
      INTEGER NET
      INTEGER NETRO0
      INTEGER STATUS
      INTEGER GETCL
      GETNF0=GETCL(NET)
      IF((GETNF0.NE.-1))GOTO 10320
        NETLA0(1)=0
        RETURN
10320 CALL EVALN0(NET,STATUS)
      NETRO0=NET
      CALL GETNG0(NETRO0,NETLA0)
      IF((NETLA0(1).EQ.186))GOTO 10321
        NETLA0(1)=0
10321 RETURN
      END
      SUBROUTINE HISTC0
      INTEGER HPTRA0(128)
      INTEGER HBUFA0(4096)
      INTEGER HBFAA0,HBLAA0,HPFAA0,HPLAA0,HLINE0,HONAA0
      COMMON /HISTCM/HBFAA0,HBLAA0,HPFAA0,HPLAA0,HLINE0,HPTRA0,HBUFA0,HO
     *NAA0
      INTEGER ARG(180)
      INTEGER STATUS,FD,JUNK
      INTEGER GETARG,EQUAL
      INTEGER HISTT0,HISTR0
      INTEGER AAACZ0
      INTEGER AAADA0(4)
      INTEGER AAADB0(3)
      INTEGER AAADC0(5)
      INTEGER AAADD0(11)
      INTEGER AAADE0(8)
      INTEGER AAADF0(11)
      INTEGER AAADG0,AAADH0,AAADI0,AAADJ0
      INTEGER AAADK0(6)
      DATA AAADA0/239,230,230,0/
      DATA AAADB0/239,238,0/
      DATA AAADC0/243,225,246,229,0/
      DATA AAADD0/189,232,233,243,244,230,233,236,229,189,0/
      DATA AAADE0/242,229,243,244,239,242,229,0/
      DATA AAADF0/189,232,233,243,244,230,233,236,229,189,0/
      DATA AAADK0/170,179,233,186,160,0/
      IF((GETARG(1,ARG,180).NE.-1))GOTO 10326
        IF((HONAA0.EQ.1))GOTO 10324
          CALL REMARK('history is not enabled.')
          RETURN
10324   AAACZ0=1
        GOTO 10322
10325   RETURN
10327   HONAA0=0
      GOTO 10328
10329   CALL HISTI0
        HONAA0=1
      GOTO 10328
10330   IF((HONAA0.EQ.1))GOTO 10331
          CALL REMARK('history is not enabled.')
          RETURN
10331   IF((GETARG(2,ARG,180).NE.-1))GOTO 10332
          CALL CTOC(AAADD0,ARG,180)
10332   IF((HISTT0(ARG).NE.-3))GOTO 10328
          CALL ERROR('can''t save command history.')
10333 GOTO 10328
10334   IF((GETARG(2,ARG,180).NE.-1))GOTO 10335
          CALL CTOC(AAADF0,ARG,180)
10335   HONAA0=0
        IF((HISTR0(ARG).NE.-3))GOTO 10336
          CALL ERROR('can''t restore command history.')
10336   HONAA0=1
      GOTO 10328
10326 IF((EQUAL(ARG,AAADA0).EQ.1))GOTO 10327
      IF((EQUAL(ARG,AAADB0).EQ.1))GOTO 10329
      IF((EQUAL(ARG,AAADC0).EQ.1))GOTO 10330
      IF((EQUAL(ARG,AAADE0).EQ.1))GOTO 10334
        CALL ERROR('Usage: hist [on | off | save [<file>] | restore [<fi
     *le>]].')
10328 CALL SWT
10322 AAADH0=HPLAA0
      AAADG0=HLINE0
10337 IF((AAADH0.EQ.HPFAA0))GOTO 10325
        CALL PRINT(-11,AAADK0,AAADG0)
        AAADJ0=MOD(AAADH0,128)+1
        IF((AAADJ0.EQ.HPFAA0))GOTO 10339
        IF((HPTRA0(AAADH0).GE.HPTRA0(AAADJ0)))GOTO 10339
          CALL PUTLIN(HBUFA0(HPTRA0(AAADH0)),-11)
          GOTO 10340
10339     IF((AAADJ0.NE.HPFAA0))GOTO 10341
          IF((HPTRA0(AAADH0).GE.HBFAA0))GOTO 10341
            CALL PUTLIN(HBUFA0(HPTRA0(AAADH0)),-11)
            GOTO 10342
10341       AAADI0=HPTRA0(AAADH0)
            GOTO 10345
10343       AAADI0=AAADI0+(1)
10345       IF((AAADI0.GT.4096))GOTO 10344
            IF((HBUFA0(AAADI0).EQ.0))GOTO 10344
              CALL PUTCH(HBUFA0(AAADI0),-11)
            GOTO 10343
10344       IF((HBUFA0(4096).EQ.0))GOTO 10346
              CALL PUTLIN(HBUFA0(1),-11)
10346     CONTINUE
10342   CONTINUE
10340   CALL PUTCH(138,-11)
        AAADH0=AAADJ0
        AAADG0=AAADG0+(1)
      GOTO 10337
      END
      SUBROUTINE IFCMD
      INTEGER ARG(102),CMD(102)
      INTEGER NESTI0
      INTEGER CKNUM,GETARG,GETNET,EQUAL
      INTEGER AAADL0(3)
      INTEGER AAADM0(5)
      INTEGER AAADN0(3)
      INTEGER AAADO0(5)
      DATA AAADL0/230,233,0/
      DATA AAADM0/229,236,243,229,0/
      DATA AAADN0/233,230,0/
      DATA AAADO0/229,236,233,230,0/
      IF((GETARG(1,ARG,102).NE.-1))GOTO 10348
        ARG(1)=0
10348 CONTINUE
10349 IF((CKNUM(ARG).NE.0))GOTO 10350
        NESTI0=0
10351     IF((GETNET(CMD,ARG).NE.-1))GOTO 10353
            CALL ERROR('missing ''fi''.')
10352     GOTO 10353
10354       IF((NESTI0.NE.0))GOTO 10355
              GOTO 10350
10355         NESTI0=NESTI0-(1)
          GOTO 10356
10357       IF((NESTI0.NE.0))GOTO 10356
              GOTO 10350
10359       NESTI0=NESTI0+(1)
          GOTO 10356
10353     IF((EQUAL(CMD,AAADL0).NE.0))GOTO 10354
          IF((EQUAL(CMD,AAADM0).NE.0))GOTO 10357
          IF((EQUAL(CMD,AAADN0).NE.0))GOTO 10359
          IF((EQUAL(CMD,AAADO0).NE.0))GOTO 10349
10356   CONTINUE
        GOTO 10351
10350 CALL SWT
      END
      INTEGER FUNCTION GETNET(CMD,ARG)
      INTEGER CMD(1),ARG(1)
      INTEGER STATUS
      INTEGER GETCL
      INTEGER COMMA0,C2
      IF((GETCL(COMMA0).NE.-1))GOTO 10361
        CMD(1)=0
        ARG(1)=0
        GETNET=-1
        RETURN
10361 CALL EVALN0(COMMA0,STATUS)
      C2=COMMA0
10362   CALL GETNG0(C2,CMD)
      IF((CMD(1).EQ.186))GOTO 10362
      CALL GETNG0(C2,ARG)
      CALL LSFREE(COMMA0,10000)
      GETNET=-2
      RETURN
      END
      INTEGER FUNCTION GETNG0(LSLINE,TOKEN)
      INTEGER LSLINE
      INTEGER TOKEN(1)
      INTEGER I
      INTEGER QUOTE,C
      INTEGER LSGETC
10363   IF((LSGETC(LSLINE,C).EQ.160))GOTO 10364
        IF((C.EQ.137))GOTO 10364
          GOTO 10365
10364 CONTINUE
      GOTO 10363
10365 I=1
10366   IF((C.EQ.167))GOTO 10368
        IF((C.EQ.162))GOTO 10368
        GOTO 10367
10368     QUOTE=C
10369       C=LSGETC(LSLINE,C)
            IF((C.NE.QUOTE))GOTO 10370
              C=LSGETC(LSLINE,C)
              GOTO 10366
10370       TOKEN(I)=C
            IF((C.NE.0))GOTO 10372
              GOTO 10373
10372       I=I+(1)
          GOTO 10369
10367     TOKEN(I)=C
          IF((C.EQ.0))GOTO 10373
          IF((C.EQ.160))GOTO 10373
          IF((C.EQ.137))GOTO 10373
          GOTO 10374
10374     I=I+(1)
          C=LSGETC(LSLINE,C)
10371 GOTO 10366
10373 TOKEN(I)=0
      IF((I.NE.1))GOTO 10376
      IF((C.NE.0))GOTO 10376
        GETNG0=-1
        RETURN
10376 GETNG0=I-1
      RETURN
      END
      SUBROUTINE INDEX0
      INTEGER C(2),STR(102)
      INTEGER INDEX,GETARG
      INTEGER AAADP0(5)
      DATA AAADP0/170,233,170,238,0/
      IF((GETARG(1,STR,102).EQ.-1))GOTO 10378
      IF((GETARG(2,C,2).EQ.-1))GOTO 10378
      GOTO 10377
10378   CALL ERROR('Usage: index <string> <character>.')
10377 CALL PRINT(-11,AAADP0,INDEX(STR,C(1)))
      CALL SWT
      END
      SUBROUTINE INSTA0
      INTEGER FD
      INTEGER OPEN
      INTEGER AAADQ0(15)
      DATA AAADQ0/189,233,238,243,244,225,236,236,225,244,233,239,238,18
     *9,0/
      FD=OPEN(AAADQ0,1)
      IF((FD.EQ.-3))GOTO 10379
        CALL FCOPY(FD,-11)
        CALL CLOSE(FD)
        GOTO 10380
10379   CALL PUTCH(138,-11)
10380 CALL SWT
      END
      SUBROUTINE LINEC0
      INTEGER VALUE(102)
      INTEGER AAADR0(5)
      DATA AAADR0/170,243,170,238,0/
      CALL DATE(4,VALUE)
      CALL PRINT(-11,AAADR0,VALUE)
      CALL SWT
      END
      SUBROUTINE LOGIO0
      INTEGER VALUE(102)
      INTEGER AAADS0(5)
      DATA AAADS0/170,243,170,238,0/
      CALL DATE(3,VALUE)
      CALL PRINT(-11,AAADS0,VALUE)
      CALL SWT
      END
      SUBROUTINE NARGS0
      INTEGER SAVEN0(10,10),SAVEO0(10,10),SAVEI0(150,10),SAVEP0(150,10)
      INTEGER SAVEQ0(6,10)
      INTEGER SAVEA0(128,10)
      INTEGER SAVER0(10)
      INTEGER SAVEC0(10)
      COMMON /SAVCOM/SAVEN0,SAVEO0,SAVEI0,SAVEP0,SAVEQ0,SAVEA0,SAVER0,SA
     *VEC0
      INTEGER CIFIL0,CIFDA0(10),CIERR0,CITRA0,CICNO0(10)
      INTEGER CIBUF0(10),CIQUO0,CISEA0,CIQUP0,CIERS0,CIPRO0,CIHEL0,CIDEF
     *0
      INTEGER CIREC0
      INTEGER * 4 CIMDA0,CIMSI0,CICHE0
      COMMON /CICOM/CIQUO0,CISEA0,CIQUP0,CIPRO0,CIHEL0,CIERS0,CIDEF0,CIF
     *IL0,CITRA0,CIREC0,CIERR0,CIFDA0,CICNO0,CIBUF0,CIMDA0,CIMSI0,CICHE0
      INTEGER ARG(10)
      INTEGER LEVEL0,BACKNO,I,J,CN,ARGTA0(2,64,1)
      INTEGER GETARG,CTOI
      INTEGER AAADT0(5)
      EQUIVALENCE (ARGTA0(1,1,1),SAVEA0(1,1))
      DATA AAADT0/170,233,170,238,0/
      IF((GETARG(1,ARG,10).NE.-1))GOTO 10381
        BACKNO=1
        GOTO 10382
10381   I=1
        BACKNO=CTOI(ARG,I)
10382 LEVEL0=CIFIL0-BACKNO
      IF((LEVEL0.LT.1))GOTO 10384
      IF((LEVEL0.GT.CIFIL0))GOTO 10384
      GOTO 10383
10384   J=1
        GOTO 10385
10383   CN=SAVEC0(LEVEL0)
        I=1
        GOTO 10388
10386   I=I+(1)
10388   IF((I.GE.SAVER0(LEVEL0)))GOTO 10387
          IF((ARGTA0(2,I,LEVEL0).LT.CN))GOTO 10386
            GOTO 10387
10387   J=0
        GOTO 10392
10390   I=I+(1)
10392   IF((I.GE.SAVER0(LEVEL0)))GOTO 10391
          IF((ARGTA0(2,I,LEVEL0).EQ.CN))GOTO 10393
            GOTO 10391
10393       J=J+(1)
        GOTO 10390
10391 CONTINUE
10385 CALL PRINT(-11,AAADT0,J-1)
      CALL SWT
      END
      SUBROUTINE OUTCMD
      CALL EXITC0
      CALL SWT
      END
      SUBROUTINE PRIMO0
      SHORTCALL MKONU$(18)
      EXTERNAL REONU$
      INTEGER AAADU0(5)
      DATA AAADU0/8,-11579,-14898,-11067,-11612/
      CALL MKONU$(AAADU0,LOC(REONU$))
      CALL COMLV$
      CALL SWT
      END
      SUBROUTINE QUOTE0
      INTEGER STATE,ANYTH0
      INTEGER GETCH
      INTEGER CH
      INTEGER AAADV0
      STATE=0
      ANYTH0=0
      GOTO 10397
10395 CONTINUE
10397 IF((GETCH(CH,-10).EQ.-1))GOTO 10396
        IF((CH.NE.138))GOTO 10398
          IF((ANYTH0.NE.0))GOTO 10399
          IF((STATE.NE.0))GOTO 10399
            STATE=162
            CALL PUTCH(STATE,-11)
10399     ANYTH0=0
          GOTO 10400
10398     ANYTH0=1
10400   IF((CH.NE.138))GOTO 10401
          AAADV0=1
          GOTO 10394
10401     IF((CH.EQ.162))GOTO 10405
          IF((CH.EQ.167))GOTO 10405
          GOTO 10404
10405     IF((STATE.EQ.CH))GOTO 10406
          IF((STATE.EQ.0))GOTO 10406
          GOTO 10404
10406       AAADV0=2
            GOTO 10394
10407       IF((CH.NE.162))GOTO 10408
              STATE=167
              GOTO 10409
10408         STATE=162
10409       CALL PUTCH(STATE,-11)
            GOTO 10410
10404       IF((193.GT.CH))GOTO 10412
            IF((CH.GT.218))GOTO 10412
            GOTO 10411
10412       IF((225.GT.CH))GOTO 10413
            IF((CH.GT.250))GOTO 10413
            GOTO 10411
10413       IF((176.GT.CH))GOTO 10414
            IF((CH.GT.185))GOTO 10414
            GOTO 10411
10414         IF((STATE.NE.0))GOTO 10415
                STATE=162
                CALL PUTCH(STATE,-11)
10415       CONTINUE
10411     CONTINUE
10410   CONTINUE
10403   CALL PUTCH(CH,-11)
      GOTO 10395
10396 AAADV0=3
      GOTO 10394
10416 CALL SWT
10394 IF((STATE.EQ.0))GOTO 10417
        CALL PUTCH(STATE,-11)
10417 STATE=0
      GOTO 10418
10418 GOTO(10403,10407,10416),AAADV0
      GOTO 10418
      END
      SUBROUTINE REPEA0
      INTEGER CIFIL0,CIFDA0(10),CIERR0,CITRA0,CICNO0(10)
      INTEGER CIBUF0(10),CIQUO0,CISEA0,CIQUP0,CIERS0,CIPRO0,CIHEL0,CIDEF
     *0
      INTEGER CIREC0
      INTEGER * 4 CIMDA0,CIMSI0,CICHE0
      COMMON /CICOM/CIQUO0,CISEA0,CIQUP0,CIPRO0,CIHEL0,CIERS0,CIDEF0,CIF
     *IL0,CITRA0,CIREC0,CIERR0,CIFDA0,CICNO0,CIBUF0,CIMDA0,CIMSI0,CICHE0
      INTEGER NEXTA0,ARGTB0(2,64)
      COMMON /ARGCOM/NEXTA0,ARGTB0
      INTEGER SAVEN0(10,10),SAVEO0(10,10),SAVEI0(150,10),SAVEP0(150,10)
      INTEGER SAVEQ0(6,10)
      INTEGER SAVEA0(128,10)
      INTEGER SAVER0(10)
      INTEGER SAVEC0(10)
      COMMON /SAVCOM/SAVEN0,SAVEO0,SAVEI0,SAVEP0,SAVEQ0,SAVEA0,SAVER0,SA
     *VEC0
      INTEGER CURNO0,CMDCU0,SYMTY0,SYMIP0,SYMOP0,SYMNO0,SYMLE0
      INTEGER SYMTE0(102),SYMST0(102)
      INTEGER CMDAA0,CMDPT0
      COMMON /PARCOM/CURNO0,CMDAA0,CMDPT0,CMDCU0,SYMTY0,SYMIP0,SYMOP0,SY
     *MNO0,SYMLE0,SYMTE0,SYMST0
      INTEGER ARGS(2048),CMD(102),LAB(1024)
      INTEGER GETNE0,EQUAL,CTOC,SHELL,PUTARG
      INTEGER NESTI0,ALEN,LEN,CODE,I,J
      INTEGER MKTEMP
      INTEGER TPTR
      INTEGER FD
      INTEGER FIRST,LAST
      INTEGER NEXTB0,CURNP0
      INTEGER ARGTA0(2,64)
      INTEGER AAADW0(12)
      INTEGER AAADX0(6)
      INTEGER AAADY0(4)
      INTEGER AAADZ0(26)
      INTEGER AAAEA0(7)
      DATA AAADW0/186,204,170,178,172,172,176,233,244,170,238,0/
      DATA AAADX0/245,238,244,233,236,0/
      DATA AAADY0/233,230,160,0/
      DATA AAADZ0/229,236,243,229,170,238,231,239,244,239,160,204,170,17
     *8,172,172,176,233,244,170,238,230,233,170,238,0/
      DATA AAAEA0/242,229,240,229,225,244,0/
      FD=MKTEMP(3)
      IF((FD.NE.-3))GOTO 10419
        CALL ERROR('can''t create temporary file for repeat loop.')
10419 I=1
      J=1
      GOTO 10422
10420 I=I+(1)
10422 IF((I.GE.NEXTA0))GOTO 10421
        IF((ARGTB0(2,I).EQ.CURNO0))GOTO 10423
          ARGTB0(2,J)=ARGTB0(2,I)
          ARGTB0(1,J)=ARGTB0(1,I)
          J=J+(1)
          GOTO 10420
10423     CALL LSFREE(ARGTB0(1,I),10000)
10424 GOTO 10420
10421 NEXTA0=J
      IF((CIFIL0.LE.1))GOTO 10425
        CURNP0=SAVEC0(CIFIL0)
        NEXTB0=SAVER0(CIFIL0)
        CALL MOVE$(SAVEA0(1,CIFIL0),ARGTA0,128)
        LAST=NEXTB0-1
        GOTO 10428
10426   LAST=LAST-(1)
10428   IF((LAST.LE.0))GOTO 10427
          IF((ARGTA0(2,LAST).GT.CURNP0))GOTO 10426
            GOTO 10427
10427   FIRST=LAST-1
        GOTO 10432
10430   FIRST=FIRST-(1)
10432   IF((FIRST.LE.0))GOTO 10431
          IF((ARGTA0(2,FIRST).EQ.CURNP0))GOTO 10430
            GOTO 10431
10431   FIRST=FIRST+(1)
        GOTO 10436
10434   FIRST=FIRST+(1)
10436   IF((FIRST.LE.0))GOTO 10435
        IF((FIRST.GT.LAST))GOTO 10435
          TPTR=0
          CALL LSCOPY(ARGTA0(1,FIRST),1,TPTR,1)
          IF((PUTARG(TPTR,CURNO0).NE.-3))GOTO 10434
            CALL SETERR(1000)
            CALL SWT
10435 CONTINUE
10425 CALL PRINT(FD,AAADW0,CIFIL0)
      NESTI0=0
10438   IF((GETNE0(CMD,ARGS,LAB).NE.-1))GOTO 10440
          CALL ERROR('missing ''until''.')
10439   GOTO 10440
10441     IF((NESTI0.NE.0))GOTO 10442
            CALL PUTLIN(LAB,FD)
            CALL PUTLIN(AAADY0,FD)
            CALL PUTLIN(ARGS,FD)
            CALL PRINT(FD,AAADZ0,CIFIL0)
            GOTO 10443
10442     NESTI0=NESTI0-(1)
          CALL PUTLIN(LAB,FD)
          CALL PUTLIN(CMD,FD)
          CALL PUTLIN(ARGS,FD)
        GOTO 10444
10445     NESTI0=NESTI0+(1)
          CALL PUTLIN(LAB,FD)
          CALL PUTLIN(CMD,FD)
          CALL PUTLIN(ARGS,FD)
        GOTO 10444
10440   IF((EQUAL(CMD,AAADX0).NE.0))GOTO 10441
        IF((EQUAL(CMD,AAAEA0).NE.0))GOTO 10445
          CALL PUTLIN(LAB,FD)
          CALL PUTLIN(CMD,FD)
          CALL PUTLIN(ARGS,FD)
10444 CONTINUE
      GOTO 10438
10443 CALL REWIND(FD)
      CODE=SHELL(FD)
      CALL RMTEMP(FD)
      IF((CODE.NE.-3))GOTO 10446
        CALL SETERR(1000)
10446 CALL SWT
      END
      INTEGER FUNCTION GETNE0(CMD,ARGS,LAB)
      INTEGER CMD(1),ARGS(1),LAB(1)
      INTEGER STATUS,ALEN,LEN
      INTEGER GETCL,NEXTR0
      INTEGER COMMA0,C2
      IF((GETCL(COMMA0).NE.-1))GOTO 10447
        CMD(1)=0
        ARGS(1)=0
        GETNE0=-1
        RETURN
10447 CALL EVALN0(COMMA0,STATUS)
      LEN=0
      C2=COMMA0
      ALEN=NEXTR0(C2,CMD)
10448 IF((ALEN.EQ.-1))GOTO 10449
      IF((CMD(1).NE.186))GOTO 10449
        CALL CTOC(CMD,LAB(LEN+1),128)
        LEN=LEN+(ALEN+1)
        LAB(LEN)=160
        ALEN=NEXTR0(C2,CMD)
      GOTO 10448
10449 IF((LEN.LE.0))GOTO 10450
        LAB(LEN)=160
        LAB(LEN+1)=0
        GOTO 10451
10450   LAB(1)=0
10451 LEN=1
      ARGS(LEN)=160
      ALEN=NEXTR0(C2,ARGS(LEN+1))
10452 IF((ALEN.EQ.-1))GOTO 10453
        LEN=LEN+(ALEN+1)
        ARGS(LEN)=160
        ALEN=NEXTR0(C2,ARGS(LEN+1))
      GOTO 10452
10453 ARGS(LEN)=138
      ARGS(LEN+1)=0
      CALL LSFREE(COMMA0,10000)
      GETNE0=-2
      RETURN
      END
      INTEGER FUNCTION NEXTR0(LSLINE,TOKEN)
      INTEGER TOKEN(1)
      INTEGER LSLINE
      INTEGER I
      INTEGER C
      INTEGER LSGETC
10454   IF((LSGETC(LSLINE,C).EQ.160))GOTO 10455
        IF((C.EQ.137))GOTO 10455
          GOTO 10456
10455 CONTINUE
      GOTO 10454
10456 I=1
10457   TOKEN(I)=C
        IF((C.EQ.0))GOTO 10460
        IF((C.EQ.160))GOTO 10460
        IF((C.EQ.137))GOTO 10460
        GOTO 10458
10458   I=I+(1)
        C=LSGETC(LSLINE,C)
      GOTO 10457
10460 TOKEN(I)=0
      IF((I.NE.1))GOTO 10461
      IF((C.NE.0))GOTO 10461
        NEXTR0=-1
        RETURN
10461 NEXTR0=I-1
      RETURN
      END
      SUBROUTINE SETCMD
      INTEGER GETARG,EQUAL
      INTEGER JUNK(3),VAR(102),VAL(102)
      INTEGER USAGE(35)
      INTEGER AAAEC0
      INTEGER AAAED0(2)
      INTEGER AAAEB0
      INTEGER AAAEE0
      INTEGER GETLIN,GETARG
      DATA USAGE/213,243,225,231,229,186,160,243,229,244,160,219,160,188
     *,246,225,242,190,160,221,160,160,189,160,160,219,160,188,229,248,2
     *40,190,160,221,0/
      DATA AAAED0/189,0/
      IF((GETARG(1,VAR,102).NE.-1))GOTO 10463
        CALL ERROR(USAGE)
10463 IF((VAR(1).NE.189))GOTO 10464
      IF((VAR(2).NE.0))GOTO 10464
        IF((GETARG(3,JUNK,1).EQ.-1))GOTO 10465
          CALL ERROR(USAGE)
10465   AAAEB0=2
        AAAEC0=1
        GOTO 10462
10466   CALL PRINT(-11,'*s*n.',VAL)
        GOTO 10467
10464   IF((GETARG(2,JUNK,3).EQ.-1))GOTO 10469
        IF((EQUAL(JUNK,AAAED0).EQ.0))GOTO 10469
        IF((GETARG(4,JUNK,1).NE.-1))GOTO 10469
        GOTO 10468
10469     CALL ERROR(USAGE)
          GOTO 10470
10468     AAAEB0=3
          AAAEC0=2
          GOTO 10462
10471     CALL SVPUT(VAR,VAL)
10470 CONTINUE
10467 CALL SWT
10462 IF((GETARG(AAAEB0,VAL,102).NE.-1))GOTO 10476
        AAAEE0=GETLIN(VAL,-10)
        IF((AAAEE0.NE.-1))GOTO 10473
          VAL(1)=0
          GOTO 10474
10473     IF((VAL(AAAEE0).NE.138))GOTO 10475
            VAL(AAAEE0)=0
10475   CONTINUE
10474 CONTINUE
10472 GOTO 10476
10476 GOTO(10466,10471),AAAEC0
      GOTO 10476
      END
      SUBROUTINE SHCMD
      INTEGER SHELL
      INTEGER MAPSU
      IF((SHELL(MAPSU(-10)).NE.-3))GOTO 10477
        CALL SETERR(1000)
10477 CALL SWT
      END
      SUBROUTINE SHTRA0
      INTEGER CIFIL0,CIFDA0(10),CIERR0,CITRA0,CICNO0(10)
      INTEGER CIBUF0(10),CIQUO0,CISEA0,CIQUP0,CIERS0,CIPRO0,CIHEL0,CIDEF
     *0
      INTEGER CIREC0
      INTEGER * 4 CIMDA0,CIMSI0,CICHE0
      COMMON /CICOM/CIQUO0,CISEA0,CIQUP0,CIPRO0,CIHEL0,CIERS0,CIDEF0,CIF
     *IL0,CITRA0,CIREC0,CIERR0,CIFDA0,CICNO0,CIBUF0,CIMDA0,CIMSI0,CICHE0
      INTEGER TRACE0,I,L
      INTEGER GETARG,STRBSR,GCTOI
      INTEGER ARG(128)
      INTEGER TRACF0(33)
      INTEGER TRACG0(239)
      INTEGER AAAEF0(7)
      DATA TRACG0/-1,225,236,236,0,-32768,227,236,0,16384,227,238,0,-327
     *68,227,239,237,237,225,238,228,223,236,233,238,229,0,16384,227,239
     *,237,240,239,245,238,228,223,238,239,228,229,0,1033,228,229,226,24
     *5,231,0,1,229,248,0,1,229,248,229,227,245,244,233,239,238,0,8192,2
     *30,238,0,8192,230,245,238,227,244,233,239,238,0,4096,233,244,0,409
     *6,233,244,229,242,225,244,233,239,238,0,16,236,233,238,235,229,228
     *,223,243,244,242,233,238,231,243,0,32,236,239,0,32,236,239,227,225
     *,244,233,239,238,0,16,236,243,0,8,238,228,0,8,238,239,228,229,0,9,
     *239,238,0,512,239,245,0,512,239,238,245,238,233,244,0,2048,240,228
     *,0,2048,240,239,242,244,223,228,229,243,227,242,233,240,244,239,24
     *2,0,1024,243,233,238,231,236,229,223,243,244,229,240,0,4,243,242,0
     *,1024,243,243,0,2,243,246,0,4,243,246,223,242,229,243,244,239,242,
     *229,0,2,243,246,223,243,225,246,229,0,64,243,249,0,64,243,249,237,
     *226,239,236,0,0,246,225,236,245,229,0/
      DATA TRACF0/32,1,6,10,14,28,43,50,54,65,69,79,83,94,110,114,124,12
     *8,132,138,142,146,154,158,175,188,192,196,200,212,221,225,233/
      DATA AAAEF0/170,172,184,234,170,238,0/
      TRACE0=CITRA0
      I=1
      GOTO 10480
10478 I=I+(1)
10480 IF((GETARG(I,ARG,128).EQ.-1))GOTO 10479
        CALL MAPSTR(ARG,1)
        L=STRBSR(TRACF0,TRACG0,1,ARG)
        IF((L.NE.-1))GOTO 10481
          L=1
          TRACE0=GCTOI(ARG,L,8)
          IF((ARG(L).EQ.0))GOTO 10478
            CALL ERROR('Usage: shtrace {<octal integer> | <option>}.')
10482     GOTO 10478
10481     TRACE0=OR(TRACE0,TRACG0(TRACF0(L)))
10483 GOTO 10478
10479 IF((I.NE.1))GOTO 10484
        TRACE0=0
10484 CALL PRINT(-11,AAAEF0,CITRA0)
      CITRA0=TRACE0
      CALL SWT
      END
      SUBROUTINE STOPC0
      INTEGER CIFIL0,CIFDA0(10),CIERR0,CITRA0,CICNO0(10)
      INTEGER CIBUF0(10),CIQUO0,CISEA0,CIQUP0,CIERS0,CIPRO0,CIHEL0,CIDEF
     *0
      INTEGER CIREC0
      INTEGER * 4 CIMDA0,CIMSI0,CICHE0
      COMMON /CICOM/CIQUO0,CISEA0,CIQUP0,CIPRO0,CIHEL0,CIERS0,CIDEF0,CIF
     *IL0,CITRA0,CIREC0,CIERR0,CIFDA0,CICNO0,CIBUF0,CIMDA0,CIMSI0,CICHE0
      COMMON /SWT$CM/TERMB0(128),TERMC0,TERMD0,ECHAR0,KCHAR0,NLCHA0,EOFC
     *H0,ESCCH0,RTCHA0,ISPHA0,CPUTY0,ERRCO0,STDPO0(6),KILLR0(33),FDMEM0(
     *16,128),RESES0(846),FDBUF0(16384),PASSW0(7),BPLAB0(4),UTEMP0,FDLAS
     *0,PRTDE0(17),PRTFO0(9),UHASH0(37),UTEMQ0(4059),RESET0(985),CMDST0,
     *COMUN0,RTLAB0(4),FIRSU0,ARGCA0,ARGVA0(256),TERMA0(6),TERMT0(7),LWO
     *RD0,LSHOA0,LSTOP0,LSNAA0,LSREF0(16384),RESEU0(743),TSSTA0,TSGTA0,T
     *SATA0,TSEOS0,TSUNA0(32),TSPSA0(32),TSBFA0(32,32),TSPWA0(3,32),TSPA
     *T0(180),RESEV0(680),NEWSC0(85,51),RESEW0(785),CURSC0(85,51),RESEX0
     *(785),TCCLE0(10),TCCLF0(10),TCCLG0(10),TCCUR0(10),TCCUS0(10),TCCUT
     *0(10),TCCUU0(10),TCCUV0(10),TCABS0(10),TCVER0(10),TCHOR0(10),TCINS
     *0(10),TCDEL0(10),TCSHI0(10),TCSHJ0(10),TCCOO0,TCSHK0,TCCOP0,TCSEQ0
     *,TCSPE0,TCCLH0,TCLIN0,TCPOS0,TCWRA0,TCCLR0,TCCEO0,TCCEP0,TCABT0,TC
     *VES0,TCHOS0,TCHOM0,TCLEF0,TCUPL0,UNPRI0,COLCH0(51),COLCI0(51),ROWC
     *H0,ROWCI0,LASTC0(51),MAXRO0,MAXCO0,CURRO0,CURCO0,MSGRO0,MSGOW0(85)
     *,PADRO0,PADCO0,PADLE0,DISPL0,FNTAB0(128,20),LASTF0,TABSA0(85),INPU
     *T0(51),INPUU0(51),INBUF0(85),LASTD0,INSER0,INVER0,DUPLE0,INPUV0,PB
     *BUF0(400),PBPTR0,FNUSE0(20),DEFBU0(1000),LASTE0,NESTJ0,RESEY0(1)
      INTEGER TERMB0,TERMC0,TERMD0,ECHAR0,KCHAR0,NLCHA0,EOFCH0,ESCCH0,RT
     *CHA0,ISPHA0,CPUTY0,ERRCO0,STDPO0,FDMEM0,RESES0,FDBUF0,PASSW0,BPLAB
     *0,UTEMP0,UHASH0,UTEMQ0,RESET0,CMDST0,COMUN0,RTLAB0,FIRSU0,ARGCA0,A
     *RGVA0,TERMA0,TERMT0,LSHOA0,LSTOP0,LSNAA0,LSREF0,RESEU0,FDLAS0,KILL
     *R0,PRTDE0,PRTFO0,LWORD0,TSSTA0,TSGTA0,TSATA0,TSEOS0,TSUNA0,TSPSA0,
     *TSBFA0,TSPWA0,TSPAT0,RESEV0,NEWSC0,RESEW0,CURSC0,RESEX0,TCCLE0,TCC
     *LF0,TCCLG0,TCCUR0,TCCUS0,TCCUT0,TCCUU0,TCCUV0,TCABS0,TCVER0,TCHOR0
     *,TCINS0,TCDEL0,TCCLH0,TCLIN0,TCPOS0,TCSHI0,TCSHJ0,TCCOO0,TCSHK0,TC
     *COP0,TCSEQ0,TCDEM0,TCWRA0,TCCLR0,TCSPE0,TCCEO0,TCCEP0,TCABT0,TCVES
     *0,TCHOS0,UNPRI0,COLCH0,COLCI0,ROWCH0,ROWCI0,LASTC0,MAXRO0,MAXCO0,C
     *URRO0,CURCO0,MSGRO0,MSGOW0,PADRO0,PADCO0,PADLE0,DISPL0,FNTAB0,LAST
     *F0,TABSA0,INPUT0,INPUU0,INBUF0,LASTD0,INSER0,INVER0,DUPLE0,INPUV0,
     *PBBUF0,PBPTR0,FNUSE0,DEFBU0,LASTE0,NESTJ0,TCHOM0,TCLEF0,TCUPL0,RES
     *EY0
      INTEGER FDESC0(16),FDDEV0(1),FDUNI0(1),FDBUG0(1),FDBUH0(1),FDBUI0(
     *1),FDCOU0(1),FDBCO0(1),FDFLA0(1),FDVCS0(1),FDVCT0(1),FDOPS0(1),FDO
     *PT0(1),FDOPU0(1)
      INTEGER HPTRA0(128)
      INTEGER HBUFA0(4096)
      INTEGER HBFAA0,HBLAA0,HPFAA0,HPLAA0,HLINE0,HONAA0
      COMMON /HISTCM/HBFAA0,HBLAA0,HPFAA0,HPLAA0,HLINE0,HPTRA0,HBUFA0,HO
     *NAA0
      INTEGER ARG(128)
      INTEGER RC,SAVET0,LOGOUT
      INTEGER GETARG
      LOGICAL TRACE
      INTEGER AAAEG0(11)
      INTEGER AAAEH0(11)
      EQUIVALENCE (FDMEM0,FDESC0),(FDDEV0,FDESC0(1)),(FDUNI0,FDESC0(2)),
     *(FDBUG0,FDESC0(3)),(FDBUH0,FDESC0(4)),(FDBUI0,FDESC0(5)),(FDCOU0,F
     *DESC0(6)),(FDBCO0,FDESC0(7)),(FDFLA0,FDESC0(8)),(FDVCS0,FDESC0(9))
     *,(FDVCT0,FDESC0(10)),(FDOPS0,FDESC0(11)),(FDOPT0,FDESC0(12)),(FDOP
     *U0,FDESC0(13))
      DATA AAAEG0/189,246,225,242,243,230,233,236,229,189,0/
      DATA AAAEH0/189,232,233,243,244,230,233,236,229,189,0/
      SAVET0=1
      IF((GETARG(1,ARG,128).EQ.-1))GOTO 10485
        LOGOUT=1
        IF((ARG(1).NE.173))GOTO 10487
        IF((ARG(2).NE.0))GOTO 10487
        GOTO 10488
10487     SAVET0=0
          CALL REMOVE(ARG)
10486   GOTO 10488
10485   LOGOUT=0
10488 IF((SAVET0.EQ.0))GOTO 10489
        TRACE=(AND(CITRA0,:2).NE.0)
        CALL SVSAVE(AAAEG0,TRACE)
        IF((HONAA0.NE.1))GOTO 10490
        IF((ISPHA0.NE.0))GOTO 10490
          CALL HISTT0(AAAEH0)
10490 CONTINUE
10489 IF((LOGOUT.EQ.0))GOTO 10491
        CALL LOGO$$(0,0,0,0,INTL(0),RC)
10491 CALL SWT
      END
      SUBROUTINE SUBST0
      INTEGER I,FIRST,CHARS
      INTEGER GETARG,GCTOI,GETLIN
      INTEGER SFIRST(10),SCHARS(10),ARG(102)
      INTEGER AAAEI0(44)
      INTEGER AAAEJ0(5)
      INTEGER AAAEK0(5)
      DATA AAAEI0/213,243,225,231,229,186,160,243,245,226,243,244,242,16
     *0,188,243,244,225,242,244,190,160,188,236,229,238,231,244,232,190,
     *160,219,160,188,243,244,242,233,238,231,190,160,221,0/
      DATA AAAEJ0/170,243,170,238,0/
      DATA AAAEK0/170,243,170,238,0/
      IF((GETARG(1,SFIRST,10).EQ.-1))GOTO 10493
      IF((GETARG(2,SCHARS,10).EQ.-1))GOTO 10493
      GOTO 10492
10493   CALL ERROR(AAAEI0)
10492 I=1
      FIRST=GCTOI(SFIRST,I,10)
      I=1
      CHARS=GCTOI(SCHARS,I,10)
      IF((GETARG(3,ARG,102).EQ.-1))GOTO 10494
        CALL SUBSTR(ARG,ARG,FIRST,CHARS)
        CALL PRINT(-11,AAAEJ0,ARG)
        GOTO 10495
10494   CONTINUE
10496     I=GETLIN(ARG,-10)
          IF((I.NE.-1))GOTO 10497
            GOTO 10498
10497     IF((ARG(I).NE.138))GOTO 10499
            ARG(I)=0
10499     CALL SUBSTR(ARG,ARG,FIRST,CHARS)
          CALL PRINT(-11,AAAEK0,ARG)
        GOTO 10496
10498 CONTINUE
10495 CALL SWT
      END
      SUBROUTINE TAKEC0
      INTEGER I,CHARS
      INTEGER GCTOI,GETLIN,GETARG
      INTEGER ARG(102)
      INTEGER AAAEL0(34)
      INTEGER AAAEM0(5)
      INTEGER AAAEN0(5)
      DATA AAAEL0/213,243,225,231,229,186,160,244,225,235,229,160,188,23
     *8,227,232,225,242,243,190,160,219,160,188,243,244,242,233,238,231,
     *190,160,221,0/
      DATA AAAEM0/170,243,170,238,0/
      DATA AAAEN0/170,243,170,238,0/
      IF((GETARG(1,ARG,102).NE.-1))GOTO 10500
        CALL ERROR(AAAEL0)
10500 I=1
      CHARS=GCTOI(ARG,I,10)
      IF((GETARG(2,ARG,102).EQ.-1))GOTO 10501
        CALL STAKE(ARG,ARG,CHARS)
        CALL PRINT(-11,AAAEM0,ARG)
        GOTO 10502
10501   CONTINUE
10503     I=GETLIN(ARG,-10)
          IF((I.NE.-1))GOTO 10504
            GOTO 10505
10504     IF((ARG(I).NE.138))GOTO 10506
            ARG(I)=0
10506     CALL STAKE(ARG,ARG,CHARS)
          CALL PRINT(-11,AAAEN0,ARG)
        GOTO 10503
10505 CONTINUE
10502 CALL SWT
      END
      SUBROUTINE TIMEC0
      INTEGER VALUE(102)
      INTEGER AAAEO0(5)
      DATA AAAEO0/170,243,170,238,0/
      CALL DATE(2,VALUE)
      CALL PRINT(-11,AAAEO0,VALUE)
      CALL SWT
      END
      SUBROUTINE VARSC0
      COMMON /SVCOM/SVLLA0,SVTBL0(32,13),SVMEM0(4096),EOFSA0(32),ESAVE0(
     *32),ESCSA0(32),KSAVE0(32),NLSAV0(32),RTSAV0(32),KRESP0(33,32),PDES
     *T0(17,32),PFORM0(9,32)
      INTEGER SVLLA0,SVTBL0,SVMEM0,EOFSA0,ESAVE0,ESCSA0,KSAVE0,NLSAV0,RT
     *SAV0,KRESP0,PDEST0,PFORM0
      INTEGER CIFIL0,CIFDA0(10),CIERR0,CITRA0,CICNO0(10)
      INTEGER CIBUF0(10),CIQUO0,CISEA0,CIQUP0,CIERS0,CIPRO0,CIHEL0,CIDEF
     *0
      INTEGER CIREC0
      INTEGER * 4 CIMDA0,CIMSI0,CICHE0
      COMMON /CICOM/CIQUO0,CISEA0,CIQUP0,CIPRO0,CIHEL0,CIERS0,CIDEF0,CIF
     *IL0,CITRA0,CIREC0,CIERR0,CIFDA0,CICNO0,CIBUF0,CIMDA0,CIMSI0,CICHE0
      INTEGER A$BUF(200)
      INTEGER I,J,NL,COL,LL,LLEND
      INTEGER CTOC,SVSAVE,SVREST
      INTEGER NAME(102),VALUE(102)
      LOGICAL TRACE
      INTEGER PARSCL
      INTEGER AAAEP0(16)
      INTEGER CTOC
      INTEGER AAAEQ0(11)
      INTEGER AAAER0(21)
      INTEGER CTOC
      INTEGER AAAES0(11)
      INTEGER AAAET0(24)
      INTEGER AAAEU0(8)
      DATA AAAEP0/225,227,231,236,246,242,188,239,243,190,243,188,239,24
     *3,190,0/
      DATA AAAEQ0/189,246,225,242,243,230,233,236,229,189,0/
      DATA AAAER0/227,225,238,167,244,160,243,225,246,229,160,246,225,24
     *2,233,225,226,236,229,243,0/
      DATA AAAES0/189,246,225,242,243,230,233,236,229,189,0/
      DATA AAAET0/227,225,238,167,244,160,242,229,243,244,239,242,229,16
     *0,246,225,242,233,225,226,236,229,243,0/
      DATA AAAEU0/160,189,160,167,170,243,167,0/
      IF((PARSCL(AAAEP0,A$BUF).NE.-3))GOTO 10507
        CALL ERROR('Usage: vars { -{a|c|g|l|v|r[<file>]|s[<file>]} }.')
10507 IF((A$BUF(242-225+1).EQ.0))GOTO 10509
      IF((A$BUF(243-225+1).EQ.0))GOTO 10509
        CALL ERROR('can''t save and restore simultaneously.')
10508 GOTO 10509
10510   IF((A$BUF(243-225+1).EQ.2))GOTO 10511
          A$BUF(243-225+27)=A$BUF(53)
          A$BUF(53)=A$BUF(53)+(1+CTOC(AAAEQ0,A$BUF(A$BUF(53)),200))
10511   TRACE=(AND(CITRA0,:2).NE.0)
        IF((SVSAVE(A$BUF(A$BUF(243-225+27)),TRACE).NE.-3))GOTO 10513
          CALL ERROR(AAAER0)
10512 GOTO 10513
10514   IF((A$BUF(242-225+1).EQ.2))GOTO 10515
          A$BUF(242-225+27)=A$BUF(53)
          A$BUF(53)=A$BUF(53)+(1+CTOC(AAAES0,A$BUF(A$BUF(53)),200))
10515   TRACE=(AND(CITRA0,:4).NE.0)
        IF((SVREST(A$BUF(A$BUF(242-225+27)),TRACE).NE.-3))GOTO 10513
          CALL ERROR(AAAET0)
10516 GOTO 10513
10513   CALL SWT
10509 IF((A$BUF(243-225+1).NE.0))GOTO 10510
      IF((A$BUF(242-225+1).NE.0))GOTO 10514
      IF((A$BUF(231-225+1).NE.0))GOTO 10518
      IF((A$BUF(236-225+1).NE.0))GOTO 10518
      GOTO 10517
10518   LLEND=1
        GOTO 10519
10517   LLEND=SVLLA0
10519 LL=SVLLA0
      GOTO 10522
10520 LL=LL-(1)
10522 IF((LL.LT.LLEND))GOTO 10521
        COL=0
        I=1
        GOTO 10525
10523   I=I+(1)
10525   IF((I.GT.13))GOTO 10524
          J=SVTBL0(LL,I)
          GOTO 10528
10526     J=SVMEM0(J+0)
10528     IF((J.EQ.0))GOTO 10523
            NL=CTOC(SVMEM0(SVMEM0(J+1)),NAME,102)
            IF((A$BUF(225-225+1).NE.0))GOTO 10529
            IF((A$BUF(236-225+1).NE.0))GOTO 10529
            IF((NAME(1).NE.223))GOTO 10529
              GOTO 10526
10529       IF((A$BUF(246-225+1).NE.0))GOTO 10531
            IF((A$BUF(236-225+1).NE.0))GOTO 10531
            GOTO 10530
10531         NL=NL+(5+CTOC(SVMEM0(SVMEM0(J+2)),VALUE,102))
10530       IF((COL.LE.0))GOTO 10532
            IF((COL+NL+(13-MOD(COL,13)).LT.80))GOTO 10532
              CALL PUTCH(138,-11)
              COL=NL
              GOTO 10533
10532         IF((COL.LE.0))GOTO 10534
10535             COL=COL+(1)
                  CALL PUTCH(160,-11)
                IF((MOD(COL,13).NE.0))GOTO 10535
10534         COL=COL+(NL)
10533       CALL PUTLIN(NAME,-11)
            IF((A$BUF(246-225+1).NE.0))GOTO 10537
            IF((A$BUF(236-225+1).NE.0))GOTO 10537
            GOTO 10536
10537         CALL PRINT(-11,AAAEU0,VALUE)
10536       IF((A$BUF(227-225+1).EQ.0))GOTO 10526
              CALL PUTCH(138,-11)
              COL=0
10538     GOTO 10526
10524   IF((COL.LE.0))GOTO 10539
          CALL PUTCH(138,-11)
10539   IF((A$BUF(231-225+1).NE.0))GOTO 10541
        IF((A$BUF(236-225+1).NE.0))GOTO 10541
        GOTO 10520
10541   IF((LL.LE.1))GOTO 10520
          CALL PUTCH(138,-11)
10540 GOTO 10520
10521 CALL SWT
      END
      SUBROUTINE VPSDC0
      INTEGER GETARG,ENCODE
      INTEGER I,LEN
      INTEGER CMD(255),ARG(255)
      INTEGER AAAEV0(10)
      INTEGER AAAEW0(5)
      DATA AAAEV0/243,247,244,243,229,231,160,170,243,0/
      DATA AAAEW0/160,177,175,177,0/
      I=1
      GOTO 10544
10542 I=I+(1)
10544 IF((GETARG(I,ARG,2).EQ.-1))GOTO 10543
      IF((ARG(1).NE.173))GOTO 10543
      GOTO 10542
10543 IF((GETARG(I,ARG,255).EQ.-1))GOTO 10545
        CALL EXPAND(ARG,CMD,255)
        CALL MKTR$(CMD,ARG)
10545 CALL DELARG(0)
      LEN=ENCODE(CMD,255,AAAEV0,ARG)
      GOTO 10548
10546 I=I-(1)
10548 IF((I.LE.1))GOTO 10547
        IF((LEN.LT.255-4))GOTO 10549
          CALL ERROR('command too long.')
10549   CMD(LEN+1)=160
        LEN=LEN+(GETARG(0,CMD(LEN+2),255-LEN-5)+1)
        CALL DELARG(0)
      GOTO 10546
10547 CALL CTOC(AAAEW0,CMD(LEN+1),5)
      CALL SYS$$(CMD,-3)
      CALL SWT
      END
      SUBROUTINE WHENC0
      CALL EXITC0
      RETURN
      END
      SUBROUTINE EXITC0
      INTEGER NESTI0
      INTEGER GETNET,EQUAL
      INTEGER CMD(102),ARG(102)
      INTEGER AAAEX0(5)
      INTEGER AAAEY0(5)
      DATA AAAEX0/229,243,225,227,0/
      DATA AAAEY0/227,225,243,229,0/
      NESTI0=0
10550 IF((GETNET(CMD,ARG).EQ.-1))GOTO 10551
        GOTO 10552
10553     IF((NESTI0.NE.0))GOTO 10554
            RETURN
10554       NESTI0=NESTI0-(1)
        GOTO 10550
10556     NESTI0=NESTI0+(1)
        GOTO 10550
10552   IF((EQUAL(CMD,AAAEX0).NE.0))GOTO 10553
        IF((EQUAL(CMD,AAAEY0).NE.0))GOTO 10556
10555 GOTO 10550
10551 CALL ERROR('missing ''esac''.')
      END
      SUBROUTINE XCMD
      INTEGER CMD(255),ARG(128)
      INTEGER I,LEN,STATUS
      INTEGER CTOC,EQUAL,FOLLOW,GETARG,INPUT,SYS$$,ISATTY
      INTEGER AAAEZ0(3)
      DATA AAAEZ0/173,228,0/
      IF((GETARG(1,ARG,128).EQ.-1))GOTO 10557
      IF((EQUAL(ARG,AAAEZ0).NE.1))GOTO 10557
        IF((GETARG(2,ARG,128).NE.-1))GOTO 10558
          CALL ERROR('Usage: x [-d <pathname>] { <primos command> }.')
          GOTO 10559
10558     IF((FOLLOW(ARG,0).EQ.-2))GOTO 10560
            CALL PUTLIN(ARG,-15)
            CALL ERROR(': bad pathname.')
            GOTO 10561
10560       CALL DELARG(1)
            CALL DELARG(1)
10561   CONTINUE
10559 CONTINUE
10557 LEN=0
      I=1
      GOTO 10564
10562 I=I+(1)
10564 IF((GETARG(I,ARG,128).EQ.-1))GOTO 10563
        IF((LEN.LE.0))GOTO 10565
          LEN=LEN+(1)
          CMD(LEN)=160
10565   LEN=LEN+(CTOC(ARG,CMD(LEN+1),255-LEN))
      GOTO 10562
10563 IF((I.LE.1))GOTO 10566
        STATUS=SYS$$(CMD,-3)
        GOTO 10567
10566   CONTINUE
10568     IF((INPUT(-10,'ok, *,#,s.',255,CMD).NE.-1))GOTO 10569
            IF((ISATTY(-10).NE.1))GOTO 10571
              CALL PUTCH(138,1)
10570       GOTO 10571
10569     STATUS=SYS$$(CMD,-10)
        IF((STATUS.EQ.-2))GOTO 10568
10571 CONTINUE
10567 IF((STATUS.NE.-3))GOTO 10572
        CALL SETERR(1000)
10572 CALL FOLLOW(0,0)
      CALL SWT
      END
C ---- Long Name Map ----
C forgetcmd                      forge0
C installationcmd                insta0
C Fdflags                        fdfla0
C Cimdate                        cimda0
C setupports                     setuq0
C singlestep                     singl0
C timecmd                        timec0
C Eofchar                        eofch0
C Inputstart                     input0
C reserveport                    reser0
C searchfor                      searc0
C Svtbl                          svtbl0
C Escchar                        escch0
C Invertcase                     inver0
C Evalue                         evalu0
C loginnamecmd                   logio0
C Tccoordchar                    tccoo0
C Tabs                           tabsa0
C Fdbufstart                     fdbug0
C histsave                       histt0
C Symiport                       symip0
C whencmd                        whenc0
C Rtchar                         rtcha0
C Prtdest                        prtde0
C Tcdelline                      tcdel0
C Colchgstop                     colci0
C Rowchgstart                    rowch0
C Maxcol                         maxco0
C Citrace                        citra0
C executenode                    execv0
C putbackcommand                 putba0
C results                        resul0
C Echar                          echar0
C Tseos                          tseos0
C Tclinedelay                    tclin0
C Fnused                         fnuse0
C checkendofexpr                 checl0
C getneta                        getne0
C initports                      initp0
C lookuplabel                    looku0
C Termcount                      termd0
C Reservedio                     reses0
C Tsstate                        tssta0
C Tccursorright                  tccut0
C Tcabspos                       tcabs0
C Tcposdelay                     tcpos0
C Tchorlen                       tchos0
C Globalcall                     globa0
C dropcmd                        dropc0
C Reservedopen                   reset0
C Lsna                           lsnaa0
C Tcseqtype                      tcseq0
C Unprintablechar                unpri0
C Fdesc                          fdesc0
C Estatus                        estat0
C Ep                             epaaa0
C Cierrorflag                    cierr0
C Symstr                         symst0
C checklabels                    check0
C dumpcmd                        dumpc0
C dumpports                      dumpp0
C histinit                       histi0
C selectport                     selec0
C Cputype                        cputy0
C Prtform                        prtfo0
C Tsbf                           tsbfa0
C Curcol                         curco0
C Lastfn                         lastf0
C Insertmode                     inser0
C argstocmd                      argst0
C histlook                       histl0
C makeportlist                   makep0
C Nlsave                         nlsav0
C Fdbuf                          fdbuf0
C Argv                           argva0
C Lstop                          lstop0
C Tcceollen                      tccep0
C Cihello                        cihel0
C argtable                       argta0
C Clear                          clear0
C Symoport                       symop0
C cleanupports                   clean0
C getnexttoken                   getng0
C histcmd                        histc0
C initconnect                    initc0
C nextunquotedchar               nextu0
C nextwhiletoken                 nextw0
C Tcshiftchar                    tcshk0
C Inputwait                      inpuv0
C Fdunit                         fduni0
C searchid                       seard0
C Cmdptr                         cmdpt0
C createlabel                    creat0
C gotocmd                        gotoc0
C Termcp                         termc0
C Kchar                          kchar0
C Fdmem                          fdmem0
C Fddev                          fddev0
C Fdvcstat1                      fdvcs0
C Cibuf                          cibuf0
C Hbf                            hbfaa0
C clrargs                        clrar0
C enterlabel                     enter0
C exitcmd                        exitd0
C loginfo                        login0
C shtracecmd                     shtra0
C lastarg                        lasta0
C Lastdef                        laste0
C Tcdelaytime                    tcdem0
C Fdvcstat2                      fdvct0
C Killresp                       killr0
C Tccleardelay                   tcclh0
C Padrow                         padro0
C Fntab                          fntab0
C Cidefaultsr                    cidef0
C varscmd                        varsc0
C Reservednewscr                 resew0
C Reservedcurscr                 resex0
C Intval                         intva0
C netlabel                       netla0
C curnode                        curnp0
C restorestate                   resto0
C vpsdcmd                        vpsdc0
C Utempbuf                       utemq0
C Rtlabel                        rtlab0
C Lsho                           lshoa0
C Tcvertpos                      tcver0
C Tcwraparound                   tcwra0
C Tchomelen                      tchom0
C Savenextiport                  saven0
C Cmd                            cmdaa0
C assigniports                   assig0
C histarg                        hista0
C Tcceoslen                      tcceo0
C Fdbufend                       fdbui0
C execute                        execu0
C findlabel                      findl0
C makeiport                      makei0
C symboltrace                    symbo0
C Tcspeed                        tcspe0
C Tcleftlen                      tclef0
C Pbbuf                          pbbuf0
C Fdopstat1                      fdops0
C netrover                       netro0
C Hbl                            hblaa0
C Saveargtable                   savea0
C Eofsave                        eofsa0
C Passwd                         passw0
C Newscr                         newsc0
C Curscr                         cursc0
C Duplex                         duple0
C Fdopstat2                      fdopt0
C syntaxerror                    synta0
C Hline                          hline0
C histrest                       histr0
C indexcmd                       index0
C primoscmd                      primo0
C Escsave                        escsa0
C Tccursorhome                   tccur0
C Fdopstat3                      fdopu0
C expression                     expre0
C levelno                        level0
C whilecmd                       while0
C Tspath                         tspat0
C Argtable                       argtb0
C clrports                       clrpo0
C initlabels                     initl0
C savestate                      saves0
C Rtsave                         rtsav0
C Tsat                           tsata0
C Tccursorleft                   tccus0
C Colchgstart                    colch0
C Ciprompt                       cipro0
C Savenextoport                  saveo0
C Saveipd                        savei0
C assignoports                   assih0
C histget                        histh0
C nargscmd                       nargs0
C nesting                        nesti0
C Esave                          esave0
C Reservedshell                  reseu0
C Inbuf                          inbuf0
C Nestingcount                   nestj0
C Savecurnode                    savec0
C savestatus                     savet0
C makeoport                      makeo0
C Reservedtscan                  resev0
C Defbuf                         defbu0
C concatenateargs                conca0
C Cifile                         cifil0
C Cierrorcontext                 ciers0
C nlevels                        nleve0
C Hptr                           hptra0
C nextarg                        nextb0
C getelement                     getel0
C stopcmd                        stopc0
C Uhashtb                        uhash0
C Fdbuflen                       fdbuh0
C Symlen                         symle0
C casecmd                        casec0
C stoplogging                    stopl0
C Cmdstat                        cmdst0
C Tchorpos                       tchor0
C Tcinsline                      tcins0
C Msgowner                       msgow0
C Hpf                            hpfaa0
C Curnode                        curno0
C Symtype                        symty0
C tracetext                      tracg0
C invokevar                      invom0
C Svll                           svlla0
C Fdlastfd                       fdlas0
C Termattr                       terma0
C Cifd                           cifda0
C Cicnodes                       cicno0
C Cisearchrule                   cisea0
C Saveporttable                  saveq0
C tracevalue                     trace0
C datecmd                        datec0
C Tsgt                           tsgta0
C Tcshiftout                     tcshj0
C Inputstop                      inpuu0
C Ciquoteopt                     ciqup0
C Saveopd                        savep0
C nextrepeattoken                nextr0
C accessarg                      acces0
C echocmd                        echoc0
C invokeint                      invol0
C substrcmd                      subst0
C Ksave                          ksave0
C Firstuse                       firsu0
C Tcshiftin                      tcshi0
C Displaytime                    displ0
C Fdcount                        fdcou0
C Symtext                        symte0
C declarecmd                     decla0
C nettrace                       nettr0
C Cirecord                       cirec0
C Cimsize                        cimsi0
C getnetlabel                    getnf0
C Termbuf                        termb0
C Lsref                          lsref0
C Tcabslen                       tcabt0
C Rowchgstop                     rowci0
C Maxrow                         maxro0
C Padcol                         padco0
C Lastcharscanned                lastd0
C Cicheck                        ciche0
C Pdestsave                      pdest0
C Msgrow                         msgro0
C Padlen                         padle0
C Hpl                            hplaa0
C Savenextarg                    saver0
C histfind                       histf0
C histsub                        hists0
C decllevel                      decll0
C Stdporttbl                     stdpo0
C Hon                            honaa0
C exitcasecmd                    exitc0
C histfree                       histg0
C histque                        histq0
C redirector                     redir0
C Argc                           argca0
C Termtype                       termt0
C Tccleartoeol                   tcclf0
C invokeext                      invok0
C takecmd                        takec0
C Tccursordown                   tccuv0
C Currow                         curro0
C Nextarg                        nexta0
C Cmdcursor                      cmdcu0
C context                        conte0
C histexp                        histe0
C setupargs                      setup0
C Pformsave                      pform0
C Nlchar                         nlcha0
C Isphantom                      ispha0
C Tsun                           tsuna0
C Tsps                           tspsa0
C Reservedvthmisc                resey0
C Token                          token0
C Ciquote                        ciquo0
C clrlabels                      clrla0
C Krespsave                      kresp0
C Tcuplen                        tcupl0
C Lastchar                       lastc0
C factor1                        facto0
C evalcmd                        evalc0
C evalnetsep                     evaln0
C linecmd                        linec0
C repeatcmd                      repea0
C Utemptop                       utemp0
C elsecmd                        elsec0
C removecn                       remov0
C Bplabel                        bplab0
C Ebuf                           ebufa0
C nodesepr                       nodes0
C Tspw                           tspwa0
C Tcclearscreen                  tccle0
C Tccoordtype                    tccop0
C Tcvertlen                      tcves0
C Fdbcount                       fdbco0
C initargs                       inita0
C initializeeverything           initi0
C processhello                   proce0
C Comunit                        comun0
C Tccleartoeos                   tcclg0
C Tccursorup                     tccuu0
C gettoken                       getto0
C command                        comma0
C Symnode                        symno0
C tracepos                       tracf0
C assignports                    assii0
C filetype                       filet0
C quotecmd                       quote0
C firstarg                       first0
C Tcclrlen                       tcclr0
C Hbuf                           hbufa0
C anything                       anyth0
C argscmd                        argsc0
C argument                       argum0
C declaredcmd                    declb0
C startlogging                   start0
C Svmem                          svmem0
C Errcod                         errco0
C Lword                          lword0
C Pbptr                          pbptr0
C Id                             idaaa0
C histprint                      histp0
