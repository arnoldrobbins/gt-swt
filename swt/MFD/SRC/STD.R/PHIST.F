      INTEGER A$BUF(200)
      INTEGER HFD
      INTEGER OPEN
      INTEGER READB0,MATCH,MAKPAT,PARSDT
      INTEGER * 4 FROMD0
      LOGICAL PRECE0
      INTEGER BUF(102),BYLINE(102),MODLI0(102),TBYLI0(102),TMODL0(102),M
     *ODULE(256),AUTHOR(256)
      INTEGER HISTO0(19)
      INTEGER AAAAA0
      INTEGER AAAAB0,AAAAC0,AAAAD0,AAAAE0
      INTEGER AAAAF0(59)
      INTEGER PARSCL
      INTEGER AAAAG0(22)
      DATA HISTO0/189,228,239,227,189,175,232,233,243,244,175,232,233,24
     *3,244,239,242,249,0/
      DATA AAAAF0/213,243,225,231,229,186,160,240,232,233,243,244,160,25
     *1,173,226,160,188,225,245,244,232,239,242,190,160,252,160,173,230,
     *160,188,228,225,244,229,190,160,252,160,173,243,160,188,243,245,22
     *6,234,229,227,244,190,160,252,160,173,241,253,0/
      DATA AAAAG0/226,188,242,243,190,230,188,242,243,190,243,188,242,24
     *3,190,233,188,242,243,190,241,0/
      AAAAA0=1
      GOTO 10000
10001 IF((A$BUF(233-225+1).EQ.0))GOTO 10002
        HFD=OPEN(A$BUF(A$BUF(233-225+27)),1)
        GOTO 10003
10002   HFD=OPEN(HISTO0,1)
10003 IF((HFD.NE.-3))GOTO 10004
        CALL ERROR('history file not available.')
10004 CALL READB0(BUF,HFD)
10005 IF((BUF(1).EQ.-1))GOTO 10006
        IF((BUF(1).NE.161))GOTO 10008
        IF((READB0(BYLINE,HFD).EQ.-1))GOTO 10008
        IF((BYLINE(1).NE.170))GOTO 10008
        IF((READB0(MODLI0,HFD).EQ.-1))GOTO 10008
        IF((MODLI0(1).NE.164))GOTO 10008
        GOTO 10007
10008     CALL CLOSE(HFD)
          CALL ERROR('history file contains apocryphal information.')
10007   IF((A$BUF(226-225+1).EQ.0))GOTO 10009
          CALL SCOPY(BYLINE,2,TBYLI0,1)
          CALL MAPSTR(TBYLI0,1)
10009   IF((A$BUF(243-225+1).EQ.0))GOTO 10010
          CALL SCOPY(MODLI0,2,TMODL0,1)
          CALL MAPSTR(TMODL0,1)
10010   IF((A$BUF(243-225+1).EQ.0))GOTO 10013
        IF((MATCH(TMODL0,MODULE).NE.0))GOTO 10013
        GOTO 10012
10013   IF((A$BUF(230-225+1).EQ.0))GOTO 10014
        IF((.NOT.PRECE0(BUF,FROMD0)))GOTO 10014
        GOTO 10012
10014   IF((A$BUF(226-225+1).EQ.0))GOTO 10015
        IF((MATCH(TBYLI0,AUTHOR).NE.0))GOTO 10015
        GOTO 10012
10015   GOTO 10011
10012     CALL SKIPE0(BUF,HFD)
          GOTO 10016
10011     IF((A$BUF(241-225+1).EQ.0))GOTO 10017
            CALL PRINT(-11,'*n*sBy: *sRe: *s.',BUF(2),BYLINE(2),MODLI0(2
     *))
            CALL SKIPE0(BUF,HFD)
            GOTO 10018
10017       CALL PRINT(-11,'*2n*s*nBy: *sRe: *s*n.',BUF(2),BYLINE(2),MOD
     *LI0(2))
            CALL READB0(BUF,HFD)
10019       IF((BUF(1).NE.163))GOTO 10020
              CALL PRINT(-11,'   *s.',BUF(2))
              CALL READB0(BUF,HFD)
            GOTO 10019
10020     CONTINUE
10018   CONTINUE
10016 GOTO 10005
10006 CALL CLOSE(HFD)
      GOTO 10021
10000 IF((PARSCL(AAAAG0,A$BUF).NE.-3))GOTO 10022
        CALL ERROR(AAAAF0)
10022 IF((A$BUF(226-225+1).EQ.0))GOTO 10023
        IF((MAKPAT(A$BUF(A$BUF(226-225+27)),1,0,AUTHOR).NE.-3))GOTO 1002
     *4
          CALL PUTLIN(A$BUF(A$BUF(226-225+27)),-15)
          CALL ERROR(': bad author pattern.')
10024 CONTINUE
10023 IF((A$BUF(230-225+1).EQ.0))GOTO 10025
        AAAAB0=1
        IF((PARSDT(A$BUF(A$BUF(230-225+27)),AAAAB0,AAAAD0,AAAAC0,AAAAE0)
     *.NE.-3))GOTO 10026
          CALL PUTLIN(A$BUF(A$BUF(230-225+27)),-15)
          CALL ERROR(': bad date.')
10026   FROMD0=INTL(AAAAE0)*10000+INTL(AAAAD0)*100+INTL(AAAAC0)
10025 IF((A$BUF(243-225+1).EQ.0))GOTO 10027
        IF((MAKPAT(A$BUF(A$BUF(243-225+27)),1,0,MODULE).NE.-3))GOTO 1002
     *8
          CALL PUTLIN(A$BUF(A$BUF(243-225+27)),-15)
          CALL ERROR(': bad subject pattern.')
10028 CONTINUE
10027 GOTO 10029
10021 CALL SWT
10029 GOTO 10001
      END
      INTEGER FUNCTION READB0(BUF,FD)
      INTEGER BUF(1)
      INTEGER FD
      INTEGER GETLIN
      READB0=GETLIN(BUF,FD)
      IF((READB0.NE.-1))GOTO 10030
        BUF(1)=-1
10030 RETURN
      END
      SUBROUTINE SKIPE0(BUF,FD)
      INTEGER BUF(1)
      INTEGER FD
      INTEGER READB0
10031   CALL READB0(BUF,FD)
      IF((BUF(1).EQ.163))GOTO 10031
      RETURN
      END
      LOGICAL FUNCTION PRECE0(DATEL0,FROM)
      INTEGER DATEL0(1)
      INTEGER * 4 FROM
      INTEGER I,YEAR,MONTH,DAY
      INTEGER INDEX
      I=INDEX(DATEL0,160)+1
      CALL PARSDT(DATEL0,I,MONTH,DAY,YEAR)
      PRECE0=INTL(YEAR)*10000+INTL(MONTH)*100+INTL(DAY).LT.FROM
      RETURN
      END
C ---- Long Name Map ----
C skipentry                      skipe0
C modline                        modli0
C dateline                       datel0
C precedes                       prece0
C tbyline                        tbyli0
C fromdate                       fromd0
C historyfile                    histo0
C readbuf                        readb0
C tmodline                       tmodl0
